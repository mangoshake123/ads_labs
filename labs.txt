
WAP to convert a given Infix expression into its equivalent Postfix expression and evaluate it using stack.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

struct Stack {
    int top;
    int capacity;
    int* array;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (int*)malloc(stack->capacity * sizeof(int));
    return stack;
}

int isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

int isFull(struct Stack* stack) {
    return stack->top == stack->capacity - 1;
}

void push(struct Stack* stack, int item) {
    if (isFull(stack)) return;
    stack->array[++stack->top] = item;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) return -1;
    return stack->array[stack->top--];
}

int peek(struct Stack* stack) {
    if (isEmpty(stack)) return -1;
    return stack->array[stack->top];
}

int precedence(char op) {
    switch(op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return -1;
    }
}

void infixToPostfix(char* infix, char* postfix) {
    struct Stack* stack = createStack(MAX_SIZE);
    int i, k;
    for (i = 0, k = -1; infix[i]; ++i) {
        if (isalnum(infix[i])) {
            postfix[++k] = infix[i];
        } else if (infix[i] == '(') {
            push(stack, infix[i]);
        } else if (infix[i] == ')') {
            while (!isEmpty(stack) && peek(stack) != '(') {
                postfix[++k] = pop(stack);
            }
            pop(stack);
        } else {
            while (!isEmpty(stack) && precedence(infix[i]) <= precedence(peek(stack))) {
                postfix[++k] = pop(stack);
            }
            push(stack, infix[i]);
        }
    }
    while (!isEmpty(stack)) {
        postfix[++k] = pop(stack);
    }
    postfix[++k] = '\0';
}

int evaluatePostfix(char* postfix) {
    struct Stack* stack = createStack(MAX_SIZE);
    int i, operand1, operand2;
    for (i = 0; postfix[i]; ++i) {
        if (isdigit(postfix[i])) {
            push(stack, postfix[i] - '0');
        } else {
            operand2 = pop(stack);
            operand1 = pop(stack);
            switch(postfix[i]) {
                case '+':
                    push(stack, operand1 + operand2);
                    break;
                case '-':
                    push(stack, operand1 - operand2);
                    break;
                case '*':
                    push(stack, operand1 * operand2);
                    break;
                case '/':
                    push(stack, operand1 / operand2);
                    break;
                case '^':
                    push(stack, operand1 ^ operand2);
                    break;
            }
        }
    }
    return pop(stack);
}

int main() {
    char infix[MAX_SIZE], postfix[MAX_SIZE];
    printf("Enter an infix expression: ");
    scanf("%s", infix);
    infixToPostfix(infix, postfix);
    printf("Postfix expression: %s\n", postfix);
    printf("Result: %d\n", evaluatePostfix(postfix));
    return 0;
}


       WAP to convert a given Infix expression into its equivalent Prefix expression and evaluate it using stack.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_SIZE 100

struct Stack {
    int top;
    int capacity;
    char* array;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (char*)malloc(stack->capacity * sizeof(char));
    return stack;
}

int isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

int isFull(struct Stack* stack) {
    return stack->top == stack->capacity - 1;
}

void push(struct Stack* stack, char item) {
    if (isFull(stack)) return;
    stack->array[++stack->top] = item;
}

char pop(struct Stack* stack) {
    if (isEmpty(stack)) return -1;
    return stack->array[stack->top--];
}

char peek(struct Stack* stack) {
    if (isEmpty(stack)) return -1;
    return stack->array[stack->top];
}

int precedence(char op) {
    switch(op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return -1;
    }
}

void infixToPrefix(char* infix, char* prefix) {
    int len = strlen(infix);
    // Reverse the infix expression
    for (int i = 0; i < len / 2; ++i) {
        char temp = infix[i];
        infix[i] = infix[len - i - 1];
        infix[len - i - 1] = temp;
    }
    // Swap '(' and ')' and reverse the precedence of operators
    for (int i = 0; i < len; ++i) {
        if (infix[i] == '(')
            infix[i] = ')';
        else if (infix[i] == ')')
            infix[i] = '(';
    }
    struct Stack* stack = createStack(MAX_SIZE);
    int i, k;
    for (i = 0, k = -1; infix[i]; ++i) {
        if (isalnum(infix[i])) {
            prefix[++k] = infix[i];
        } else if (infix[i] == '(') {
            push(stack, infix[i]);
        } else if (infix[i] == ')') {
            while (!isEmpty(stack) && peek(stack) != '(') {
                prefix[++k] = pop(stack);
            }
            pop(stack);
        } else {
            while (!isEmpty(stack) && precedence(infix[i]) < precedence(peek(stack))) {
                prefix[++k] = pop(stack);
            }
            push(stack, infix[i]);
        }
    }
    while (!isEmpty(stack)) {
        prefix[++k] = pop(stack);
    }
    prefix[++k] = '\0';
    // Reverse the prefix expression to get the final result
    len = strlen(prefix);
    for (int i = 0; i < len / 2; ++i) {
        char temp = prefix[i];
        prefix[i] = prefix[len - i - 1];
        prefix[len - i - 1] = temp;
    }
}

int evaluatePrefix(char* prefix) {
    struct Stack* stack = createStack(MAX_SIZE);
    int i, operand1, operand2;
    for (i = 0; prefix[i]; ++i) {
        if (isdigit(prefix[i])) {
            push(stack, prefix[i] - '0');
        } else {
            operand1 = pop(stack);
            operand2 = pop(stack);
            switch(prefix[i]) {
                case '+':
                    push(stack, operand1 + operand2);
                    break;
                case '-':
                    push(stack, operand1 - operand2);
                    break;
                case '*':
                    push(stack, operand1 * operand2);
                    break;
                case '/':
                    push(stack, operand1 / operand2);
                    break;
                case '^':
                    push(stack, operand1 ^ operand2);
                    break;
            }
        }
    }
    return pop(stack);
}

int main() {
    char infix[MAX_SIZE], prefix[MAX_SIZE];
    printf("Enter an infix expression: ");
    scanf("%s", infix);
    infixToPrefix(infix, prefix);
    printf("Prefix expression: %s\n", prefix);
    printf("Result: %d\n", evaluatePrefix(prefix));
    return 0;
}


       WAP to implement two stack using array and perform following operations on it. A. PUSH, B. POP, C. StackFull D. StackeEmpty E. Display Stack.
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

struct TwoStacks {
    int top1; // Top index of the first stack
    int top2; // Top index of the second stack
    int array[MAX_SIZE]; // Array to store elements of both stacks
};

struct TwoStacks* createTwoStacks() {
    struct TwoStacks* stacks = (struct TwoStacks*)malloc(sizeof(struct TwoStacks));
    stacks->top1 = -1; // Initialize top index of the first stack
    stacks->top2 = MAX_SIZE; // Initialize top index of the second stack
    return stacks;
}

int isStack1Full(struct TwoStacks* stacks) {
    return stacks->top1 == stacks->top2 - 1;
}

int isStack2Full(struct TwoStacks* stacks) {
    return stacks->top2 == stacks->top1 + 1;
}

int isStack1Empty(struct TwoStacks* stacks) {
    return stacks->top1 == -1;
}

int isStack2Empty(struct TwoStacks* stacks) {
    return stacks->top2 == MAX_SIZE;
}

void push1(struct TwoStacks* stacks, int data) {
    if (isStack1Full(stacks)) {
        printf("Stack 1 overflow\n");
        return;
    }
    stacks->array[++stacks->top1] = data;
}

void push2(struct TwoStacks* stacks, int data) {
    if (isStack2Full(stacks)) {
        printf("Stack 2 overflow\n");
        return;
    }
    stacks->array[--stacks->top2] = data;
}

int pop1(struct TwoStacks* stacks) {
    if (isStack1Empty(stacks)) {
        printf("Stack 1 underflow\n");
        return -1;
    }
    return stacks->array[stacks->top1--];
}

int pop2(struct TwoStacks* stacks) {
    if (isStack2Empty(stacks)) {
        printf("Stack 2 underflow\n");
        return -1;
    }
    return stacks->array[stacks->top2++];
}

void displayStack1(struct TwoStacks* stacks) {
    if (isStack1Empty(stacks)) {
        printf("Stack 1 is empty\n");
        return;
    }
    printf("Stack 1: ");
    for (int i = stacks->top1; i >= 0; i--) {
        printf("%d ", stacks->array[i]);
    }
    printf("\n");
}

void displayStack2(struct TwoStacks* stacks) {
    if (isStack2Empty(stacks)) {
        printf("Stack 2 is empty\n");
        return;
    }
    printf("Stack 2: ");
    for (int i = stacks->top2; i < MAX_SIZE; i++) {
        printf("%d ", stacks->array[i]);
    }
    printf("\n");
}

void displayBothStacks(struct TwoStacks* stacks) {
    displayStack1(stacks);
    displayStack2(stacks);
}

int main() {
    struct TwoStacks* stacks = createTwoStacks();

    push1(stacks, 10);
    push1(stacks, 20);
    push1(stacks, 30);

    push2(stacks, 40);
    push2(stacks, 50);
    push2(stacks, 60);

    displayBothStacks(stacks);

    pop1(stacks);
    pop2(stacks);

    displayBothStacks(stacks);

    return 0;
}



       WAP to implement following by using stack.
 A. Factorial of a given number B. Generation of Fibonacci series
A.Factorial
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

struct Stack {
    int top;
    int capacity;
    int* array;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (int*)malloc(stack->capacity * sizeof(int));
    return stack;
}

int isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

int isFull(struct Stack* stack) {
    return stack->top == stack->capacity - 1;
}

void push(struct Stack* stack, int data) {
    if (isFull(stack)) {
        printf("Stack overflow\n");
        return;
    }
    stack->array[++stack->top] = data;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack underflow\n");
        return -1;
    }
    return stack->array[stack->top--];
}

int factorial(int n) {
    struct Stack* stack = createStack(MAX_SIZE);
    int fact = 1;
    for (int i = 1; i <= n; i++) {
        push(stack, i);
    }
    while (!isEmpty(stack)) {
        fact *= pop(stack);
    }
    return fact;
}

int main() {
    int n;
    printf("Enter a number: ");
    scanf("%d", &n);
    printf("Factorial of %d is %d\n", n, factorial(n));
    return 0;
}


B.Fibonacci
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

struct Stack {
    int top;
    int capacity;
    int* array;
};

struct Stack* createStack(int capacity) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (int*)malloc(stack->capacity * sizeof(int));
    return stack;
}

int isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

int isFull(struct Stack* stack) {
    return stack->top == stack->capacity - 1;
}

void push(struct Stack* stack, int data) {
    if (isFull(stack)) {
        printf("Stack overflow\n");
        return;
    }
    stack->array[++stack->top] = data;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack underflow\n");
        return -1;
    }
    return stack->array[stack->top--];
}

void generateFibonacci(int n) {
    struct Stack* stack = createStack(MAX_SIZE);
    int a = 0, b = 1, c;
    printf("Fibonacci series up to %d terms: ", n);
    for (int i = 1; i <= n; i++) {
        printf("%d ", a);
        push(stack, a);
        c = a + b;
        a = b;
        b = c;
    }
    printf("\n");
    printf("Fibonacci series retrieved from stack: ");
    while (!isEmpty(stack)) {
        printf("%d ", pop(stack));
    }
    printf("\n");
}

int main() {
    int n;
    printf("Enter the number of terms for Fibonacci series: ");
    scanf("%d", &n);
    generateFibonacci(n);
    return 0;
}



 	Write a Program to implement circular double ended queue where user can add and remove the elements from both front and rear of the queue
#include <stdio.h>
#include <stdlib.h>

#define MAX 5

typedef struct {
    int arr[MAX];
    int front;
    int rear;
} Deque;

void initialize(Deque *dq) {
    dq->front = -1;
    dq->rear = -1;
}

int isFull(Deque *dq) {
    return ((dq->front == 0 && dq->rear == MAX - 1) || dq->front == dq->rear + 1);
}

int isEmpty(Deque *dq) {
    return (dq->front == -1);
}

void insertFront(Deque *dq, int item) {
    if (isFull(dq)) {
        printf("Queue Overflow\n");
        return;
    }

    if (dq->front == -1) {
        dq->front = 0;
        dq->rear = 0;
    } else if (dq->front == 0) {
        dq->front = MAX - 1;
    } else {
        dq->front = dq->front - 1;
    }

    dq->arr[dq->front] = item;
}

void insertRear(Deque *dq, int item) {
    if (isFull(dq)) {
        printf("Queue Overflow\n");
        return;
    }

    if (dq->front == -1) {
        dq->front = 0;
        dq->rear = 0;
    } else if (dq->rear == MAX - 1) {
        dq->rear = 0;
    } else {
        dq->rear = dq->rear + 1;
    }

    dq->arr[dq->rear] = item;
}

void deleteFront(Deque *dq) {
    if (isEmpty(dq)) {
        printf("Queue Underflow\n");
        return;
    }

    printf("Element deleted from front is %d\n", dq->arr[dq->front]);

    if (dq->front == dq->rear) {
        dq->front = -1;
        dq->rear = -1;
    } else if (dq->front == MAX - 1) {
        dq->front = 0;
    } else {
        dq->front = dq->front + 1;
    }
}

void deleteRear(Deque *dq) {
    if (isEmpty(dq)) {
        printf("Queue Underflow\n");
        return;
    }

    printf("Element deleted from rear is %d\n", dq->arr[dq->rear]);

    if (dq->front == dq->rear) {
        dq->front = -1;
        dq->rear = -1;
    } else if (dq->rear == 0) {
        dq->rear = MAX - 1;
    } else {
        dq->rear = dq->rear - 1;
    }
}

void display(Deque *dq) {
    int i;

    if (isEmpty(dq)) {
        printf("Queue is empty\n");
        return;
    }

    printf("Queue elements are:\n");

    if (dq->front <= dq->rear) {
        for (i = dq->front; i <= dq->rear; i++)
            printf("%d ", dq->arr[i]);
    } else {
        for (i = dq->front; i < MAX; i++)
            printf("%d ", dq->arr[i]);
        for (i = 0; i <= dq->rear; i++)
            printf("%d ", dq->arr[i]);
    }

    printf("\n");
}

int main() {
    Deque dq;
    initialize(&dq);
    int choice, item;

    while (1) {
        printf("\n1. Insert at front\n");
        printf("2. Insert at rear\n");
        printf("3. Delete from front\n");
        printf("4. Delete from rear\n");
        printf("5. Display\n");
        printf("6. Quit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Input the element for insertion in front: ");
                scanf("%d", &item);
                insertFront(&dq, item);
                break;
            case 2:
                printf("Input the element for insertion in rear: ");
                scanf("%d", &item);
                insertRear(&dq, item);
                break;
            case 3:
                deleteFront(&dq);
                break;
            case 4:
                deleteRear(&dq);
                break;
            case 5:
                display(&dq);
                break;
            case 6:
                exit(0);
            default:
                printf("Wrong choice\n");
        }
    }

    return 0;
}


________________________________________

 	Write a Program to implement multiple two queues using array and perform following operations on it. A. Addq, B. Delq, C. Display Queue.
#include <stdio.h>
#include <stdlib.h>

#define MAX 10

typedef struct {
    int arr[MAX];
    int front1, rear1;
    int front2, rear2;
} TwoQueues;

void initialize(TwoQueues *queues) {
    queues->front1 = -1;
    queues->rear1 = -1;
    queues->front2 = MAX;
    queues->rear2 = MAX;
}

int isFull1(TwoQueues *queues) {
    return (queues->rear1 + 1 == queues->front2);
}

int isFull2(TwoQueues *queues) {
    return (queues->rear2 - 1 == queues->rear1);
}

int isEmpty1(TwoQueues *queues) {
    return (queues->front1 == -1);
}

int isEmpty2(TwoQueues *queues) {
    return (queues->front2 == MAX);
}

void Addq1(TwoQueues *queues, int item) {
    if (isFull1(queues)) {
        printf("Queue 1 Overflow\n");
        return;
    }

    if (queues->front1 == -1) {
        queues->front1 = 0;
    }
    queues->rear1++;
    queues->arr[queues->rear1] = item;
}

void Addq2(TwoQueues *queues, int item) {
    if (isFull2(queues)) {
        printf("Queue 2 Overflow\n");
        return;
    }

    if (queues->front2 == MAX) {
        queues->front2 = MAX - 1;
    }
    queues->rear2--;
    queues->arr[queues->rear2] = item;
}

void Delq1(TwoQueues *queues) {
    if (isEmpty1(queues)) {
        printf("Queue 1 Underflow\n");
        return;
    }

    printf("Element deleted from Queue 1 is %d\n", queues->arr[queues->front1]);
    if (queues->front1 == queues->rear1) {
        queues->front1 = -1;
        queues->rear1 = -1;
    } else {
        queues->front1++;
    }
}

void Delq2(TwoQueues *queues) {
    if (isEmpty2(queues)) {
        printf("Queue 2 Underflow\n");
        return;
    }

    printf("Element deleted from Queue 2 is %d\n", queues->arr[queues->front2]);
    if (queues->front2 == queues->rear2) {
        queues->front2 = MAX;
        queues->rear2 = MAX;
    } else {
        queues->front2--;
    }
}

void displayQueue1(TwoQueues *queues) {
    if (isEmpty1(queues)) {
        printf("Queue 1 is empty\n");
        return;
    }

    printf("Queue 1 elements are:\n");
    for (int i = queues->front1; i <= queues->rear1; i++) {
        printf("%d ", queues->arr[i]);
    }
    printf("\n");
}

void displayQueue2(TwoQueues *queues) {
    if (isEmpty2(queues)) {
        printf("Queue 2 is empty\n");
        return;
    }

    printf("Queue 2 elements are:\n");
    for (int i = queues->front2; i >= queues->rear2; i--) {
        printf("%d ", queues->arr[i]);
    }
    printf("\n");
}

int main() {
    TwoQueues queues;
    initialize(&queues);
    int choice, item, queueNumber;

    while (1) {
        printf("\n1. Addq\n");
        printf("2. Delq\n");
        printf("3. Display Queue\n");
        printf("4. Quit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter queue number (1 or 2): ");
                scanf("%d", &queueNumber);
                printf("Input the element to add: ");
                scanf("%d", &item);
                if (queueNumber == 1) {
                    Addq1(&queues, item);
                } else if (queueNumber == 2) {
                    Addq2(&queues, item);
                } else {
                    printf("Invalid queue number\n");
                }
                break;
            case 2:
                printf("Enter queue number (1 or 2): ");
                scanf("%d", &queueNumber);
                if (queueNumber == 1) {
                    Delq1(&queues);
                } else if (queueNumber == 2) {
                    Delq2(&queues);
                } else {
                    printf("Invalid queue number\n");
                }
                break;
            case 3:
                printf("Enter queue number (1 or 2): ");
                scanf("%d", &queueNumber);
                if (queueNumber == 1) {
                    displayQueue1(&queues);
                } else if (queueNumber == 2) {
                    displayQueue2(&queues);
                } else {
                    printf("Invalid queue number\n");
                }
                break;
            case 4:
                exit(0);
            default:
                printf("Wrong choice\n");
        }
    }

    return 0;
}
       WAP to perform addition of two polynomials using singly linked list.
________________________________________
 	Write an iterative Reverse() function that reverses a list by rearranging all the next pointers and the head pointer. Ideally, Reverse() should only need to make one pass of the list.
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

void Reverse(struct Node** headRef) {
    struct Node* prev = NULL;
    struct Node* current = *headRef;
    struct Node* next = NULL;
    
    while (current != NULL) {
        next = current->next;  // Store next node
        current->next = prev;  // Reverse current node's pointer
        prev = current;        // Move pointers one position ahead
        current = next;
    }
    *headRef = prev;  // Update head to new front
}

void push(struct Node** headRef, int newData) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = newData;
    newNode->next = *headRef;
    *headRef = newNode;
}

void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* head = NULL;

    push(&head, 5);
    push(&head, 4);
    push(&head, 3);
    push(&head, 2);
    push(&head, 1);

    printf("Original List: \n");
    printList(head);

    Reverse(&head);

    printf("Reversed List: \n");
    printList(head);

    return 0;
}
       WAP to create doubly linked list and perform following operations on it. A) Insert (all cases) 2. Delete (all cases).
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

void insertAtBeginning(struct Node** headRef, int data) {
    struct Node* newNode = createNode(data);
    newNode->next = *headRef;
    if (*headRef != NULL) {
        (*headRef)->prev = newNode;
    }
    *headRef = newNode;
}

void insertAtEnd(struct Node** headRef, int data) {
    struct Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    struct Node* temp = *headRef;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
    newNode->prev = temp;
}

void insertAfter(struct Node* prevNode, int data) {
    if (prevNode == NULL) {
        printf("The given previous node cannot be NULL\n");
        return;
    }
    struct Node* newNode = createNode(data);
    newNode->next = prevNode->next;
    prevNode->next = newNode;
    newNode->prev = prevNode;
    if (newNode->next != NULL) {
        newNode->next->prev = newNode;
    }
}

void deleteFromBeginning(struct Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    struct Node* temp = *headRef;
    *headRef = (*headRef)->next;
    if (*headRef != NULL) {
        (*headRef)->prev = NULL;
    }
    free(temp);
}

void deleteFromEnd(struct Node** headRef) {
    if (*headRef == NULL) {
        printf("List is empty\n");
        return;
    }
    struct Node* temp = *headRef;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    if (temp->prev != NULL) {
        temp->prev->next = NULL;
    } else {
        *headRef = NULL;
    }
    free(temp);
}

void deleteNode(struct Node** headRef, struct Node* delNode) {
    if (*headRef == NULL || delNode == NULL) {
        printf("The given node cannot be deleted\n");
        return;
    }
    if (*headRef == delNode) {
        *headRef = delNode->next;
    }
    if (delNode->next != NULL) {
        delNode->next->prev = delNode->prev;
    }
    if (delNode->prev != NULL) {
        delNode->prev->next = delNode->next;
    }
    free(delNode);
}

void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* head = NULL;

    insertAtBeginning(&head, 1);
    insertAtBeginning(&head, 2);
    insertAtBeginning(&head, 3);
    printf("List after inserting at beginning: ");
    printList(head);

 
    insertAtEnd(&head, 4);
    insertAtEnd(&head, 5);
    printf("List after inserting at end: ");
    printList(head);

    insertAfter(head->next, 6);
    printf("List after inserting after the second node: ");
    printList(head);

    deleteFromBeginning(&head);
    printf("List after deleting from beginning: ");
    printList(head);

    deleteFromEnd(&head);
    printf("List after deleting from end: ");
    printList(head);

    deleteNode(&head, head->next);
    printf("List after deleting the second node: ");
    printList(head);

    return 0;
}


       WAP to merge two sorted Doubly linked lists and display their result.
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

void insertAtEnd(struct Node** headRef, int data) {
    struct Node* newNode = createNode(data);
    if (*headRef == NULL) {
        *headRef = newNode;
        return;
    }
    struct Node* temp = *headRef;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
    newNode->prev = temp;
}

struct Node* mergeSortedLists(struct Node* head1, struct Node* head2) {
    if (head1 == NULL) return head2;
    if (head2 == NULL) return head1;

    struct Node* mergedHead = NULL;

    if (head1->data <= head2->data) {
        mergedHead = head1;
        head1 = head1->next;
    } else {
        mergedHead = head2;
        head2 = head2->next;
    }

    struct Node* mergedTail = mergedHead;

    while (head1 != NULL && head2 != NULL) {
        if (head1->data <= head2->data) {
            mergedTail->next = head1;
            head1->prev = mergedTail;
            head1 = head1->next;
        } else {
            mergedTail->next = head2;
            head2->prev = mergedTail;
            head2 = head2->next;
        }
        mergedTail = mergedTail->next;
    }

    if (head1 != NULL) {
        mergedTail->next = head1;
        head1->prev = mergedTail;
    } else if (head2 != NULL) {
        mergedTail->next = head2;
        head2->prev = mergedTail;
    }

    return mergedHead;
}

void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* head1 = NULL;
    struct Node* head2 = NULL;

    
    insertAtEnd(&head1, 1);
    insertAtEnd(&head1, 3);
    insertAtEnd(&head1, 5);

    insertAtEnd(&head2, 2);
    insertAtEnd(&head2, 4);
    insertAtEnd(&head2, 6);

    printf("First Sorted List: ");
    printList(head1);

    printf("Second Sorted List: ");
    printList(head2);

    struct Node* mergedHead = mergeSortedLists(head1, head2);

    printf("Merged Sorted List: ");
    printList(mergedHead);

    return 0;
}


       Implement Push and POP operations of STACK on Doubly linked lists
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

void push(struct Node** topRef, int data) {
    struct Node* newNode = createNode(data);
    if (*topRef != NULL) {
        newNode->next = *topRef;
        (*topRef)->prev = newNode;
    }
    *topRef = newNode;
    printf("Pushed %d onto the stack\n", data);
}

int pop(struct Node** topRef) {
    if (*topRef == NULL) {
        printf("Stack underflow\n");
        return -1;
    }
    struct Node* temp = *topRef;
    int poppedData = temp->data;
    *topRef = temp->next;
    if (*topRef != NULL) {
        (*topRef)->prev = NULL;
    }
    free(temp);
    printf("Popped %d from the stack\n", poppedData);
    return poppedData;
}

void printStack(struct Node* top) {
    struct Node* temp = top;
    printf("Stack: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* top = NULL;

    push(&top, 10);
    push(&top, 20);
    push(&top, 30);

    printStack(top);

    pop(&top);
    pop(&top);

    printStack(top);

    pop(&top);

    pop(&top);

    return 0;
}


       Implement ADD and DELETE operations of QUEUE on Doubly linked lists
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};

struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

void add(struct Node** frontRef, struct Node** rearRef, int data) {
    struct Node* newNode = createNode(data);
    if (*rearRef == NULL) {
        *frontRef = *rearRef = newNode;
    } else {
        (*rearRef)->next = newNode;
        newNode->prev = *rearRef;
        *rearRef = newNode;
    }
    printf("Added %d to the queue\n", data);
}

int delete(struct Node** frontRef, struct Node** rearRef) {
    if (*frontRef == NULL) {
        printf("Queue underflow\n");
        return -1;
    }
    struct Node* temp = *frontRef;
    int deletedData = temp->data;
    *frontRef = (*frontRef)->next;
    if (*frontRef != NULL) {
        (*frontRef)->prev = NULL;
    } else {
        *rearRef = NULL;
    }
    free(temp);
    printf("Deleted %d from the queue\n", deletedData);
    return deletedData;
}

void printQueue(struct Node* front) {
    struct Node* temp = front;
    printf("Queue: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
    struct Node* front = NULL;
    struct Node* rear = NULL;

    add(&front, &rear, 10);
    add(&front, &rear, 20);
    add(&front, &rear, 30);

    printQueue(front);

    delete(&front, &rear);
    delete(&front, &rear);

    printQueue(front);

    delete(&front, &rear);
    
    delete(&front, &rear);

    return 0;
}






 Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Preorder Traversal b. Count Leaf Nodes c. Count total no. of nodes d. Display height of a tree.
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Definition of the stack used for non-recursive traversals
struct stackNode {
    struct node *treeNode;
    struct stackNode *next;
};

// Stack operations
struct stackNode *stackTop = NULL;

// Function to push a node onto the stack
void push(struct node *t) {
    struct stackNode *newNode = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->treeNode = t;
    newNode->next = stackTop;
    stackTop = newNode;
}

// Function to pop a node from the stack
struct node *pop() {
    if (stackTop == NULL) {
        printf("Stack is empty\n");
        return NULL;
    } else {
        struct node *temp = stackTop->treeNode;
        struct stackNode *t = stackTop;
        stackTop = stackTop->next;
        free(t);
        return temp;
    }
}

// Function to create a new binary tree node
struct node *createNode(int key) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    newNode->data = key;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Function for non-recursive Preorder Traversal
void preorderTraversal(struct node *root) {
    struct node *current = root;
    while (current != NULL || stackTop != NULL) {
        while (current != NULL) {
            printf("%d ", current->data);
            push(current);
            current = current->left;
        }
        current = pop();
        current = current->right;
    }
    printf("\n");
}

// Function to insert a node into the binary tree
struct node *insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else {
        root->right = insert(root->right, data);
    }
    return root;
}

// Function to count the total number of nodes in the binary tree
int countTotalNodes(struct node *root) {
    if (root == NULL) return 0;

    struct node *current;
    struct stackNode *tempStack = NULL;
    int count = 0;

    push(root);
    while (stackTop != NULL) {
        current = pop();
        count++;
        if (current->right) push(current->right);
        if (current->left) push(current->left);
    }
    return count;
}

// Function to count the number of leaf nodes in the binary tree
int countLeafNodes(struct node *root) {
    if (root == NULL) return 0;

    struct node *current;
    int leafCount = 0;
    push(root);

    while (stackTop != NULL) {
        current = pop();
        if (current->left == NULL && current->right == NULL) {
            leafCount++;
        }
        if (current->right) push(current->right);
        if (current->left) push(current->left);
    }
    return leafCount;
}

// Function to find the height of the binary tree
int findHeight(struct node *root) {
    if (root == NULL) return 0;

    struct node *current;
    struct stackNode *tempStack = NULL;
    int maxHeight = 0, currentHeight = 0;

    push(root);
    while (stackTop != NULL) {
        current = pop();
        if (current->left == NULL && current->right == NULL) {
            if (currentHeight > maxHeight) {
                maxHeight = currentHeight;
            }
        }
        if (current->right) {
            push(current->right);
            currentHeight++;
        }
        if (current->left) {
            push(current->left);
            currentHeight++;
        }
    }
    return maxHeight;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 12);
    root = insert(root, 7);
    root = insert(root, 5);
    root = insert(root, 8);
    root = insert(root, 11);
    root = insert(root, 14);

    printf("Non-recursive Preorder Traversal: ");
    preorderTraversal(root);

    int totalNodes = countTotalNodes(root);
    printf("Total number of nodes: %d\n", totalNodes);

    int leafNodes = countLeafNodes(root);
    printf("Number of leaf nodes: %d\n", leafNodes);

    int height = findHeight(root);
    printf("Height of the tree: %d\n", height);

    return 0;
}



Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Inorder Traversal b. Mirror Image c. Count total no. of nodes d. Display height of a tree.

#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

struct node* createNode(int data);
void inorderNonRecursive(struct node *root);
void mirrorImage(struct node *root);
int countNodes(struct node *root);
int height(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);
int queueSize(struct queueNode *front);
struct node* insert(struct node *root, int data);

// Create a new node for the binary tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Perform inorder traversal of the binary tree (non-recursive)
void inorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *top = NULL;
    struct node *current = root;

    while (current != NULL || top != NULL) {
        while (current != NULL) {
            push(&top, current);
            current = current->left;
        }
        current = pop(&top);
        printf("%d ", current->data);
        current = current->right;
    }
    printf("\n");
}

// Generate the mirror image of the binary tree
void mirrorImage(struct node *root) {
    if (root == NULL) {
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        struct node *temp = current->left;
        current->left = current->right;
        current->right = temp;

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
}

// Count total number of nodes in the binary tree
int countNodes(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    struct queueNode *front = NULL, *rear = NULL;
    int count = 0;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        count++;

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    return count;
}

// Calculate the height of the binary tree
int height(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    struct queueNode *front = NULL, *rear = NULL;
    int height = 0;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        int size = queueSize(front);
        while (size > 0) {
            struct node *current = dequeue(&front, &rear);
            if (current->left != NULL) {
                enqueue(&front, &rear, current->left);
            }
            if (current->right != NULL) {
                enqueue(&front, &rear, current->right);
            }
            size--;
        }
        height++;
    }
    return height;
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

// Get the size of the queue
int queueSize(struct queueNode *front) {
    int size = 0;
    while (front != NULL) {
        size++;
        front = front->next;
    }
    return size;
}

// Insert a node into the binary tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        root = createNode(data);
    } else {
        if (data <= root->data) {
            root->left = insert(root->left, data);
        } else {
            root->right = insert(root->right, data);
        }
    }
    return root;
}

int main() {
    struct node *root = NULL;

    // Inserting nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 12);
    root = insert(root, 7);
    root = insert(root, 5);
    root = insert(root, 8);
    root = insert(root, 11);
    root = insert(root, 14);
    printf("Inorder Traversal: ");
    inorderNonRecursive(root);

    mirrorImage(root);
    printf("Mirror Image: ");
    inorderNonRecursive(root);

    printf("Total Number of Nodes: %d\n", countNodes(root));
    printf("Height of the Tree: %d\n", height(root));

    return 0;
    }

Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Postorder Traversal b. Display Leaf Nodes c. Count total no. of  Leaf nodes d. Display height of a tree.
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Function prototypes
void postorderTraversal(struct node *root);
void displayLeafNodes(struct node *root);
int countLeafNodes(struct node *root);
int height(struct node *root);
struct node *insert(struct node *root, int data);

// Insert a node into the binary tree
struct node *insert(struct node *root, int data) {
    if (root == NULL) {
        root = (struct node *)malloc(sizeof(struct node));
        if (root == NULL) {
            printf("Memory allocation failed\n");
            exit(1);
        }
        root->data = data;
        root->left = NULL;
        root->right = NULL;
    } else {
        if (data <= root->data) {
            root->left = insert(root->left, data);
        } else {
            root->right = insert(root->right, data);
        }
    }
    return root;
}

// Perform postorder traversal of the binary tree
void postorderTraversal(struct node *root) {
    if (root == NULL) {
        return;
    }
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    printf("%d ", root->data);
}

// Display leaf nodes of the binary tree
void displayLeafNodes(struct node *root) {
    if (root == NULL) {
        return;
    }
    if (root->left == NULL && root->right == NULL) {
        printf("%d ", root->data);
    }
    displayLeafNodes(root->left);
    displayLeafNodes(root->right);
}

// Count total number of leaf nodes in the binary tree
int countLeafNodes(struct node *root) {
    if (root == NULL) {
        return 0;
    }
    if (root->left == NULL && root->right == NULL) {
        return 1;
    }
    return countLeafNodes(root->left) + countLeafNodes(root->right);
}

// Calculate the height of the binary tree
int height(struct node *root) {
    if (root == NULL) {
        return 0;
    }
    int leftHeight = height(root->left);
    int rightHeight = height(root->right);
    return (leftHeight > rightHeight) ? (leftHeight + 1) : (rightHeight + 1);
}

int main() {
    struct node *root = NULL;

    // Inserting nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 12);
    root = insert(root, 7);
    root = insert(root, 5);
    root = insert(root, 8);
    root = insert(root, 11);
    root = insert(root, 14);

    printf("Postorder Traversal: ");
    postorderTraversal(root);
    printf("\n");

    printf("Leaf Nodes: ");
    displayLeafNodes(root);
    printf("\n");

    printf("Total Number of Leaf Nodes: %d\n", countLeafNodes(root));

    printf("Height of the Tree: %d\n", height(root));

    return 0;
}



Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Level-wise Traversal b. Display Leaf Nodes c. Count total no. of Leaf nodes d. Display height of a tree.
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
void levelOrderTraversal(struct node *root);
void displayLeafNodes(struct node *root);
int countLeafNodes(struct node *root);
int height(struct node *root);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);
int queueSize(struct queueNode *front);

// Create a new node for the binary tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Perform level-wise traversal of the binary tree (non-recursive)
void levelOrderTraversal(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        printf("%d ", current->data);

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Display leaf nodes of the binary tree
void displayLeafNodes(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    printf("Leaf Nodes: ");
    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        if (current->left == NULL && current->right == NULL) {
            printf("%d ", current->data);
        }
        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Count total number of leaf nodes in the binary tree
int countLeafNodes(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    struct queueNode *front = NULL, *rear = NULL;
    int count = 0;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        if (current->left == NULL && current->right == NULL) {
            count++;
        }
        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    return count;
}

// Calculate the height of the binary tree
int height(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    struct queueNode *front = NULL, *rear = NULL;
    int height = 0;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        int size = queueSize(front);
        while (size > 0) {
            struct node *current = dequeue(&front, &rear);
            if (current->left != NULL) {
                enqueue(&front, &rear, current->left);
            }
            if (current->right != NULL) {
                enqueue(&front, &rear, current->right);
            }
            size--;
        }
        height++;
    }
    return height;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL)
        {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

// Get the size of the queue
int queueSize(struct queueNode *front) {
    int size = 0;
    while (front != NULL) {
        size++;
        front = front->next;
    }
    return size;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 12);
    root = insert(root, 7);
    root = insert(root, 5);
    root = insert(root, 8);
    root = insert(root, 11);
    root = insert(root, 14);

    printf("Level-wise Traversal: ");
    levelOrderTraversal(root);

    displayLeafNodes(root);

    printf("Total Number of Leaf Nodes: %d\n", countLeafNodes(root));
    printf("Height of the Tree: %d\n", height(root));

    return 0;
}




________________________________________
 	Write a Program to create a Binary Tree and perform following non-recursive operations on it. a. Levelwise display b. Mirror image c. Display height of a tree.
#include <stdio.h>
 	#include <stdlib.h>
 	
 	// Definition of the binary tree node
 	struct node {
 	    int data;
 	    struct node *left, *right;
 	};
 	
 	// Queue node structure for level-wise traversal
 	struct queueNode {
 	    struct node *TreeNode;
 	    struct queueNode *next;
 	};
 	
 	// Function prototypes
 	struct node* createNode(int data);
 	struct node* insert(struct node *root, int data);
 	void levelOrderTraversal(struct node *root);
 	void mirrorImage(struct node *root);
 	int height(struct node *root);
 	void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
 	struct node* dequeue(struct queueNode **front, struct queueNode **rear);
 	int queueSize(struct queueNode *front);
 	
 	// Create a new node for the binary tree
 	struct node* createNode(int data) {
 	    struct node *newNode = (struct node *)malloc(sizeof(struct node));
 	    if (newNode == NULL) {
 	        printf("Memory allocation failed\n");
 	        exit(1);
 	    }
 	    newNode->data = data;
 	    newNode->left = NULL;
 	    newNode->right = NULL;
 	    return newNode;
 	}
 	
 	// Insert a node into the binary tree
 	struct node* insert(struct node *root, int data) {
 	    if (root == NULL) {
 	        return createNode(data);
 	    }
 	    if (data < root->data) {
 	        root->left = insert(root->left, data);
 	    } else if (data > root->data) {
 	        root->right = insert(root->right, data);
 	    }
 	    return root;
 	}
 	
 	// Perform level-wise traversal of the binary tree (non-recursive)
 	void levelOrderTraversal(struct node *root) {
 	    if (root == NULL) {
 	        printf("Tree is empty.\n");
 	        return;
 	    }
 	
 	    struct queueNode *front = NULL, *rear = NULL;
 	    enqueue(&front, &rear, root);
 	
 	    while (front != NULL) {
 	        struct node *current = dequeue(&front, &rear);
 	        printf("%d ", current->data);
 	
 	        if (current->left != NULL) {
 	            enqueue(&front, &rear, current->left);
 	        }
 	        if (current->right != NULL) {
 	            enqueue(&front, &rear, current->right);
 	        }
 	    }
 	    printf("\n");
 	}
 	
 	// Generate the mirror image of the binary tree
 	void mirrorImage(struct node *root) {
 	    if (root == NULL) {
 	        return;
 	    }
 	
 	    struct queueNode *front = NULL, *rear = NULL;
 	    enqueue(&front, &rear, root);
 	
 	    while (front != NULL) {
 	        struct node *current = dequeue(&front, &rear);
 	        struct node *temp = current->left;
 	        current->left = current->right;
 	        current->right = temp;
 	
 	        if (current->left != NULL) {
 	            enqueue(&front, &rear, current->left);
 	        }
 	        if (current->right != NULL) {
 	            enqueue(&front, &rear, current->right);
 	        }
 	    }
 	}
 	
 	// Calculate the height of the binary tree
 	int height(struct node *root) {
 	    if (root == NULL) {
 	        return 0;
 	    }
 	
 	    struct queueNode *front = NULL, *rear = NULL;
 	    int height = 0;
 	    enqueue(&front, &rear, root);
 	
 	    while (front != NULL) {
 	        int size = queueSize(front);
 	        while (size > 0) {
 	            struct node *current = dequeue(&front, &rear);
 	            if (current->left != NULL) {
 	                enqueue(&front, &rear, current->left);
 	            }
 	            if (current->right != NULL) {
 	                enqueue(&front, &rear, current->right);
 	            }
 	            size--;
 	        }
 	        height++;
 	    }
 	    return height;
 	}
 	
 	// Enqueue a node into the queue for level-wise traversal
 	void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
 	    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
 	    if (temp == NULL) {
 	        printf("Memory allocation failed\n");
 	        exit(1);
 	    }
 	    temp->TreeNode = TreeNode;
 	    temp->next = NULL;
 	    if (*rear == NULL) {
 	        *front = *rear = temp;
 	    } else {
 	        (*rear)->next = temp;
 	        *rear = temp;
 	    }
 	}
 	
 	// Dequeue a node from the queue for level-wise traversal
 	struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
 	    if (*front == NULL) {
 	        printf("Queue is empty\n");
 	        exit(1);
 	    }
 	    struct queueNode *temp = *front;
 	    struct node *TreeNode = temp->TreeNode;
 	    *front = (*front)->next;
 	    if (*front == NULL) {
 	        *rear = NULL;
 	    }
 	    free(temp);
 	    return TreeNode;
 	}
 	
 	// Get the size of the queue
 	int queueSize(struct queueNode *front) {
 	    int size = 0;
 	    while (front != NULL) {
 	        size++;
 	        front = front->next;
 	    }
 	    return size;
 	}
 	
 	int main() {
 	    struct node *root = NULL;
 	
 	    // Insert nodes into the binary tree
 	    root = insert(root, 10);
 	    root = insert(root, 12);
 	    root = insert(root, 7);
 	    root = insert(root, 5);
 	    root = insert(root, 8);
 	    root = insert(root, 11);
 	    root = insert(root, 14);
 	
 	    printf("Level-wise Traversal: ");
 	    levelOrderTraversal(root);
 	
 	    mirrorImage(root);
 	    printf("Mirror Image: ");
 	    levelOrderTraversal(root);
 	
 	    printf("Height of the Tree: %d\n", height(root));
 	
 	    return 0;
 	}
 	

________________________________________
       Write a program to illustrate operations on a BST holding numeric keys. The menu must include: • Insert • Delete • Find 
• Level wise Display
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
struct node* deleteNode(struct node *root, int key);
struct node* minValueNode(struct node *node);
struct node* find(struct node *root, int key);
void levelOrderTraversal(struct node *root);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);
int queueSize(struct queueNode *front);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Delete a node from the binary search tree
struct node* deleteNode(struct node *root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }
        struct node *temp = minValueNode(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Find the node with the minimum value in a subtree
struct node* minValueNode(struct node *node) {
    struct node *current = node;
    while (current && current->left != NULL) {
        current = current->left;
    }
    return current;
}

// Find a node with the given key in the binary search tree
struct node* find(struct node *root, int key) {
    while (root != NULL) {
        if (key == root->data) {
            return root;
        } else if (key < root->data) {
            root = root->left;
        } else {
            root = root->right;
        }
    }
    return NULL;
}

// Perform level-wise traversal of the binary search tree (non-recursive)
void levelOrderTraversal(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        printf("%d ", current->data);

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

// Get the size of the queue
int queueSize(struct queueNode *front) {
    int size = 0;
    while (front != NULL) {
        size++;
        front = front->next;
    }
    return size;
}

int main() {
    struct node *root = NULL;

    while (1) {
        printf("\nBinary Search Tree Operations:\n");
        printf("1. Insert\n");
        printf("2. Delete\n");
        printf("3. Find\n");
        printf("4. Level-wise Display\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                int data;
                printf("Enter the data to insert: ");
                scanf("%d", &data);
                root = insert(root, data);
                printf("Data %d inserted into the tree.\n", data);
                break;
            }
            case 2: {
                int key;
                printf("Enter the key to delete: ");
                scanf("%d", &key);
                root = deleteNode(root, key);
                printf("Node with key %d deleted from the tree.\n", key);
                break;
            }
            case 3: {
                int key;
                printf("Enter the key to find: ");
                scanf("%d", &key);
                struct node *foundNode = find(root, key);
                if (foundNode != NULL) {
                    printf("Node with key %d found in the tree.\n", key);
                } else {
                    printf("Node with key %d not found in the tree.\n", key);
                }
                break;
            }
            case 4:
                printf("Level-wise Display: ");
                levelOrderTraversal(root);
                break;
            case 5:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice!\n");
        }
    }

    return 0;
}


________________________________________
       Write a program to illustrate operations on a BST holding numeric keys. The menu must include: • Insert • Mirror Image       • Find • Height of the tree
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
struct node* deleteNode(struct node *root, int key);
struct node* minValueNode(struct node *node);
struct node* find(struct node *root, int key);
void levelOrderTraversal(struct node *root);
void mirrorImage(struct node *root);
int height(struct node *root);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);
int queueSize(struct queueNode *front);
struct node* cloneTree(struct node *root);
void inorderTraversal(struct node *root);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Delete a node from the binary search tree
struct node* deleteNode(struct node *root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }
        struct node *temp = minValueNode(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Find the node with the minimum value in a subtree
struct node* minValueNode(struct node *node) {
    struct node *current = node;
    while (current && current->left != NULL) {
        current = current->left;
    }
    return current;
}

// Find a node with the given key in the binary search tree
struct node* find(struct node *root, int key) {
    while (root != NULL) {
        if (key == root->data) {
            return root;
        } else if (key < root->data) {
            root = root->left;
        } else {
            root = root->right;
        }
    }
    return NULL;
}

// Perform level-wise traversal of the binary search tree (non-recursive)
void levelOrderTraversal(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        printf("%d ", current->data);

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Generate the mirror image of the binary search tree
void mirrorImage(struct node *root) {
    if (root == NULL) {
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        struct node *temp = current->left;
        current->left = current->right;
        current->right = temp;

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
}

// Calculate the height of the binary search tree
int height(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    struct queueNode *front = NULL, *rear = NULL;
    int height = 0;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        int size = queueSize(front);
        while (size > 0) {
            struct node *current = dequeue(&front, &rear);
            if (current->left != NULL) {
                enqueue(&front, &rear, current->left);
            }
            if (current->right != NULL) {
                enqueue(&front, &rear, current->right);
            }
            size--;
        }
        height++;
    }
    return height;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

// Get the size of the queue
int queueSize(struct queueNode *front) {
    int size = 0;
    while (front != NULL) {
        size++;
        front = front->next;
    }
    return size;
}

// Clone a binary tree
struct node* cloneTree(struct node *root) {
    if (root == NULL) {
        return NULL;
    }
    struct node *newNode = createNode(root->data);
    newNode->left = cloneTree(root->left);
    newNode->right = cloneTree(root->right);
    return newNode;
}

// Perform in-order traversal to display the tree
void inorderTraversal(struct node *root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);
        inorderTraversal(root->right);
    }
}

int main() {
    struct node *root = NULL;

    while (1) {
        printf("\nBinary Search Tree Operations:\n");
        printf("1. Insert\n");
        printf("2. Mirror Image\n");
        printf("3. Find\n");
        printf("4. Height of the tree\n");
        printf("5. Level-wise Display\n");
        printf("6. Display Original Tree In-order\n");
        printf("7. Display Mirror Image In-order\n");
        printf("8. Exit\n");
        printf("Enter your choice: ");
        int choice;
        scanf("%d", &choice);

        switch (choice) {
            case 1: {
                int data;
                printf("Enter the data to insert: ");
                scanf("%d", &data);
                root = insert(root, data);
                printf("Data %d inserted into the tree.\n", data);
                break;
            }
            case 2: {
                struct node *mirrorRoot = cloneTree(root);
                printf("Generating Mirror Image...\n");
                mirrorImage(mirrorRoot);
                printf("Mirror Image generated successfully.\n");

                // Display mirror image tree
                printf("Mirror Image In-order Traversal: ");
                inorderTraversal(mirrorRoot);
                printf("\n");
                break;
            }
            case 3: {
                int key;
                printf("Enter the key to find: ");
                scanf("%d", &key);
                struct node *foundNode = find(root, key);
                if (foundNode != NULL) {
                    printf("Node with key %d found in the tree.\n", key);
                } else {
                    printf("Node with key %d not found in the tree.\n", key);
                }
                break;
            }
            case 4:
                printf("Height of the Tree: %d\n", height(root));
                break;
            case 5:
                printf("Level-wise Display: ");
                levelOrderTraversal(root);
                break;
            case 6:
                printf("Original Tree In-order Traversal: ");
                inorderTraversal(root);
                printf("\n");
                break;
            case 7: {
                struct node *mirrorRoot = cloneTree(root);
                mirrorImage(mirrorRoot);
                printf("Mirror Image In-order Traversal: ");
                inorderTraversal(mirrorRoot);
                printf("\n");
                break;
            }
            case 8:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice!\n");
        }
    }

    return 0;
}


       Write a Program to create a Binary Tree and perform following Non-recursive operations on it. a. Postorder Traversal  c. Display Leaf Nodes d. Mirror Image
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
void postorderNonRecursive(struct node *root);
void displayLeafNodes(struct node *root);
void mirrorImage(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);

// Create a new node for the binary tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Perform postorder traversal of the binary tree (non-recursive)
void postorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack1 = NULL;
    struct stackNode *stack2 = NULL;
    push(&stack1, root);

    while (stack1 != NULL) {
        struct node *current = pop(&stack1);
        push(&stack2, current);

        if (current->left != NULL) {
            push(&stack1, current->left);
        }
        if (current->right != NULL) {
            push(&stack1, current->right);
        }
    }

    printf("Postorder Traversal: ");
    while (stack2 != NULL) {
        struct node *temp = pop(&stack2);
        printf("%d ", temp->data);
    }
    printf("\n");
}

// Display leaf nodes of the binary tree
void displayLeafNodes(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    printf("Leaf Nodes: ");
    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        if (current->left == NULL && current->right == NULL) {
            printf("%d ", current->data);
        }
        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Generate the mirror image of the binary tree
void mirrorImage(struct node *root) {
    if (root == NULL) {
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        struct node *temp = current->left;
        current->left = current->right;
        current->right = temp;

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 12);
    root = insert(root, 18);

    // Perform postorder traversal
    printf("Postorder Traversal: ");
    postorderNonRecursive(root);

    // Display leaf nodes
    displayLeafNodes(root);

    // Generate mirror image
    printf("Generating Mirror Image...\n");
    mirrorImage(root);
    printf("Mirror Image generated successfully.\n");

    return 0;
}



       Write a Program to create a Binary Search Tree and perform following non-recursive operations on it. a. Inorder Traversal b. Display Number of Leaf Nodes c. Mirror Image
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
void postorderNonRecursive(struct node *root);
void displayLeafNodes(struct node *root);
void mirrorImage(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);
struct node* cloneTree(struct node *root);
void inorderTraversal(struct node *root);

// Create a new node for the binary tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Perform postorder traversal of the binary tree (non-recursive)
void postorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack1 = NULL;
    struct stackNode *stack2 = NULL;
    push(&stack1, root);

    while (stack1 != NULL) {
        struct node *current = pop(&stack1);
        push(&stack2, current);

        if (current->left != NULL) {
            push(&stack1, current->left);
        }
        if (current->right != NULL) {
            push(&stack1, current->right);
        }
    }

    printf("Postorder Traversal: ");
    while (stack2 != NULL) {
        struct node *temp = pop(&stack2);
        printf("%d ", temp->data);
    }
    printf("\n");
}

// Display leaf nodes of the binary tree
void displayLeafNodes(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    printf("Leaf Nodes: ");
    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        if (current->left == NULL && current->right == NULL) {
            printf("%d ", current->data);
        }
        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Generate the mirror image of the binary tree
void mirrorImage(struct node *root) {
    if (root == NULL) {
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        struct node *temp = current->left;
        current->left = current->right;
        current->right = temp;

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

// Clone a binary tree
struct node* cloneTree(struct node *root) {
    if (root == NULL) {
        return NULL;
    }
    struct node *newNode = createNode(root->data);
    newNode->left = cloneTree(root->left);
    newNode->right = cloneTree(root->right);
    return newNode;
}

// Perform in-order traversal to display the tree
void inorderTraversal(struct node *root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);
        inorderTraversal(root->right);
    }
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary tree
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 12);
    root = insert(root, 18);

    // Display the original tree
    printf("Original Tree In-order Traversal: ");
    inorderTraversal(root);
    printf("\n");

    // Create a mirror image of the tree
    struct node *mirrorRoot = cloneTree(root);
    mirrorImage(mirrorRoot);

    // Display the mirror image tree
    printf("Mirror Image Tree In-order Traversal: ");
    inorderTraversal(mirrorRoot);
    printf("\n");

    return 0;
}


       Write a Program to create a Binary Search Tree and perform following non-recursive operations on it. a. Preorder Traversal b. Display total Number of Nodes C. Display Leaf nodes.
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
void preorderNonRecursive(struct node *root);
int countNodes(struct node *root);
void displayLeafNodes(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Perform preorder traversal of the binary search tree (non-recursive)
void preorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack = NULL;
    push(&stack, root);

    printf("Preorder Traversal: ");
    while (stack != NULL) {
        struct node *current = pop(&stack);
        printf("%d ", current->data);

        if (current->right != NULL) {
            push(&stack, current->right);
        }
        if (current->left != NULL) {
            push(&stack, current->left);
        }
    }
    printf("\n");
}

// Count the total number of nodes in the binary search tree
int countNodes(struct node *root) {
    if (root == NULL) {
        return 0;
    }

    int count = 0;
    struct stackNode *stack = NULL;
    push(&stack, root);

    while (stack != NULL) {
        struct node *current = pop(&stack);
        count++;

        if (current->right != NULL) {
            push(&stack, current->right);
        }
        if (current->left != NULL) {
            push(&stack, current->left);
        }
    }
    return count;
}

// Display the leaf nodes of the binary search tree
void displayLeafNodes(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack = NULL;
    push(&stack, root);

    printf("Leaf Nodes: ");
    while (stack != NULL) {
        struct node *current = pop(&stack);
        if (current->left == NULL && current->right == NULL) {
            printf("%d ", current->data);
        }
        if (current->right != NULL) {
            push(&stack, current->right);
        }
        if (current->left != NULL) {
            push(&stack, current->left);
        }
    }
    printf("\n");
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary search tree
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 12);
    root = insert(root, 18);

    // Perform preorder traversal
    preorderNonRecursive(root);

    // Display the total number of nodes
    printf("Total Number of Nodes: %d\n", countNodes(root));

    // Display the leaf nodes
    displayLeafNodes(root);

    return 0;
}



       Write a Program to create a Binary Search Tree and perform deletion of a node from it. Also display the tree in nonrecursive postorder way.
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
struct node* deleteNode(struct node *root, int key);
void postorderNonRecursive(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Delete a node from the binary search tree
struct node* deleteNode(struct node *root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }
        struct node *temp = root->right;
        while (temp->left != NULL) {
            temp = temp->left;
        }
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Perform postorder traversal of the binary search tree (non-recursive)
void postorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack1 = NULL, *stack2 = NULL;
    push(&stack1, root);

    while (stack1 != NULL) {
        struct node *current = pop(&stack1);
        push(&stack2, current);

        if (current->left != NULL) {
            push(&stack1, current->left);
        }
        if (current->right != NULL) {
            push(&stack1, current->right);
        }
    }

    printf("Postorder Traversal: ");
    while (stack2 != NULL) {
        struct node *current = pop(&stack2);
        printf("%d ", current->data);
    }
    printf("\n");
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary search tree
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 12);
    root = insert(root, 18);

    // Perform postorder traversal
    postorderNonRecursive(root);

    // Delete a node from the binary search tree
    int key = 15;
    root = deleteNode(root, key);
    printf("Node with key %d deleted from the tree.\n", key);

    // Perform postorder traversal after deletion
        printf("Postorder Traversal after deletion: ");
    postorderNonRecursive(root);

    return 0;
}

// User input
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Stack node structure for non-recursive traversal
struct stackNode {
    struct node *TreeNode;
    struct stackNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
struct node* deleteNode(struct node *root, int key);
void postorderNonRecursive(struct node *root);
void push(struct stackNode **top, struct node *TreeNode);
struct node* pop(struct stackNode **top);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Delete a node from the binary search tree
struct node* deleteNode(struct node *root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }
        struct node *temp = root->right;
        while (temp->left != NULL) {
            temp = temp->left;
        }
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Perform postorder traversal of the binary search tree (non-recursive)
void postorderNonRecursive(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct stackNode *stack1 = NULL, *stack2 = NULL;
    push(&stack1, root);

    while (stack1 != NULL) {
        struct node *current = pop(&stack1);
        push(&stack2, current);

        if (current->left != NULL) {
            push(&stack1, current->left);
        }
        if (current->right != NULL) {
            push(&stack1, current->right);
        }
    }

    printf("Postorder Traversal: ");
    while (stack2 != NULL) {
        struct node *current = pop(&stack2);
        printf("%d ", current->data);
    }
    printf("\n");
}

// Push a node onto the stack
void push(struct stackNode **top, struct node *TreeNode) {
    struct stackNode *temp = (struct stackNode *)malloc(sizeof(struct stackNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = *top;
    *top = temp;
}

// Pop a node from the stack
struct node* pop(struct stackNode **top) {
    if (*top == NULL) {
        printf("Stack is empty\n");
        exit(1);
    }
    struct stackNode *temp = *top;
    struct node *TreeNode = temp->TreeNode;
    *top = (*top)->next;
    free(temp);
    return TreeNode;
}

int main() {
    struct node *root = NULL;
    int choice, data, key;

    while (1) {
        printf("\nMenu:\n");
        printf("1. Insert\n");
        printf("2. Delete\n");
        printf("3. Postorder Traversal\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the data to insert: ");
                scanf("%d", &data);
                root = insert(root, data);
                break;
            case 2:
                printf("Enter the key to delete: ");
                scanf("%d", &key);
                root = deleteNode(root, key);
                printf("Node with key %d deleted from the tree.\n", key);
                break;
            case 3:
                printf("Postorder Traversal: ");
                postorderNonRecursive(root);
                break;
            case 4:
                exit(0);
                break;
            default:
                printf("Invalid choice!\n");
                break;
        }
    }

    return 0;
}



       Write a Program to create a Binary Search Tree and display it levelwise. Also perform deletion of a node from it.
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Definition of the binary search tree node
struct node {
    int data;
    struct node *left, *right;
};

// Queue node structure for level-wise traversal
struct queueNode {
    struct node *TreeNode;
    struct queueNode *next;
};

// Function prototypes
struct node* createNode(int data);
struct node* insert(struct node *root, int data);
void levelOrderTraversal(struct node *root);
struct node* deleteNode(struct node *root, int key);
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode);
struct node* dequeue(struct queueNode **front, struct queueNode **rear);

// Create a new node for the binary search tree
struct node* createNode(int data) {
    struct node *newNode = (struct node *)malloc(sizeof(struct node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert a node into the binary search tree
struct node* insert(struct node *root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Perform level-wise traversal of the binary search tree (non-recursive)
void levelOrderTraversal(struct node *root) {
    if (root == NULL) {
        printf("Tree is empty.\n");
        return;
    }

    struct queueNode *front = NULL, *rear = NULL;
    enqueue(&front, &rear, root);

    printf("Level-wise Display:\n");
    while (front != NULL) {
        struct node *current = dequeue(&front, &rear);
        printf("%d ", current->data);

        if (current->left != NULL) {
            enqueue(&front, &rear, current->left);
        }
        if (current->right != NULL) {
            enqueue(&front, &rear, current->right);
        }
    }
    printf("\n");
}

// Delete a node from the binary search tree
struct node* deleteNode(struct node *root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->data) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->data) {
        root->right = deleteNode(root->right, key);
    } else {
        // Node with only one child or no child
        if (root->left == NULL) {
            struct node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct node *temp = root->left;
            free(root);
            return temp;
        }

        // Node with two children: Get the inorder successor (smallest in the right subtree)
        struct node *temp = root->right;
        while (temp->left != NULL) {
            temp = temp->left;
        }

        // Copy the inorder successor's content to this node
        root->data = temp->data;

        // Delete the inorder successor
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// Enqueue a node into the queue for level-wise traversal
void enqueue(struct queueNode **front, struct queueNode **rear, struct node *TreeNode) {
    struct queueNode *temp = (struct queueNode *)malloc(sizeof(struct queueNode));
    if (temp == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    temp->TreeNode = TreeNode;
    temp->next = NULL;
    if (*rear == NULL) {
        *front = *rear = temp;
    } else {
        (*rear)->next = temp;
        *rear = temp;
    }
}

// Dequeue a node from the queue for level-wise traversal
struct node* dequeue(struct queueNode **front, struct queueNode **rear) {
    if (*front == NULL) {
        printf("Queue is empty\n");
        exit(1);
    }
    struct queueNode *temp = *front;
    struct node *TreeNode = temp->TreeNode;
    *front = (*front)->next;
    if (*front == NULL) {
        *rear = NULL;
    }
    free(temp);
    return TreeNode;
}

int main() {
    struct node *root = NULL;

    // Insert nodes into the binary search tree
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 15);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 12);
    root = insert(root, 18);

    // Display the tree level-wise
    levelOrderTraversal(root);

    // Delete a node from the tree
    int key;
    printf("Enter the key to delete from the tree: ");
    scanf("%d", &key);
    root = deleteNode(root, key);

    // Display the tree level-wise after deletion
    levelOrderTraversal(root);

    return 0;
}


       Write a Program to create a Binary Search Tree and display its mirror image with and without disturbing the original tree. Also display height of a tree using nonrecursion.
________________________________________
#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
typedef struct Node {
    int data;
    struct Node *left, *right;
} Node;

// Function to create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a node in the BST
Node* insert(Node* root, int data) {
    if (root == NULL) {
        return createNode(data);
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Function to print the BST in-order
void inorder(Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// Function to create a mirror image of the BST
Node* mirror(Node* root) {
    if (root == NULL) {
        return NULL;
    }
    Node* mirrorNode = createNode(root->data);
    mirrorNode->left = mirror(root->right);
    mirrorNode->right = mirror(root->left);
    return mirrorNode;
}

// Function to find the height of the BST using level-order traversal (non-recursive)
int height(Node* root) {
    if (root == NULL) {
        return 0;
    }
    int height = 0;
    Node* queue[100]; // Assuming the tree height won't exceed 100 levels
    int front = 0, rear = 0;
    queue[rear++] = root;

    while (front < rear) {
        int nodeCount = rear - front;
        height++;
        while (nodeCount > 0) {
            Node* node = queue[front++];
            if (node->left) {
                queue[rear++] = node->left;
            }
            if (node->right) {
                queue[rear++] = node->right;
            }
            nodeCount--;
        }
    }
    return height;
}

// Main function
int main() {
    Node* root = NULL;
    int choice, data;

    while (1) {
        printf("\n1. Insert\n2. Display In-order\n3. Display Mirror In-order\n4. Display Height\n5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the data to insert: ");
                scanf("%d", &data);
                root = insert(root, data);
                break;
            case 2:
                printf("In-order display of BST: ");
                inorder(root);
                printf("\n");
                break;
            case 3: {
                Node* mirrorRoot = mirror(root);
                printf("In-order display of Mirror Image of BST: ");
                inorder(mirrorRoot);
                printf("\n");
                free(mirrorRoot); // Free the mirror tree to avoid memory leak
                break;
            }
            case 4:
                printf("Height of the BST: %d\n", height(root));
                break;
            case 5:
                exit(0);
                break;
            default:
                printf("Invalid choice!\n");
                break;
        }
    }

    return 0;
}

       Write a program to efficiently search a particular employee record by using Tree data structure. Also sort the data on emp-id in ascending order.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// Definition of the employee structure
struct employee {
    int emp_id;
    char name[50];
    struct employee *left, *right;
};

// Function prototypes
struct employee* createEmployee(int emp_id, const char *name);
struct employee* insertEmployee(struct employee *root, int emp_id, const char *name);
struct employee* searchEmployee(struct employee *root, int emp_id);
void inorderTraversal(struct employee *root);

// Create a new employee node
struct employee* createEmployee(int emp_id, const char *name) {
    struct employee *newEmployee = (struct employee *)malloc(sizeof(struct employee));
    if (newEmployee == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newEmployee->emp_id = emp_id;
    strcpy(newEmployee->name, name);
    newEmployee->left = NULL;
    newEmployee->right = NULL;
    return newEmployee;
}

// Insert an employee record into the binary search tree
struct employee* insertEmployee(struct employee *root, int emp_id, const char *name) {
    if (root == NULL) {
        return createEmployee(emp_id, name);
    }
    if (emp_id < root->emp_id) {
        root->left = insertEmployee(root->left, emp_id, name);
    } else if (emp_id > root->emp_id) {
        root->right = insertEmployee(root->right, emp_id, name);
    }
    return root;
}

// Search for an employee record by employee ID
struct employee* searchEmployee(struct employee *root, int emp_id) {
    if (root == NULL || root->emp_id == emp_id) {
        return root;
    }
    if (emp_id < root->emp_id) {
        return searchEmployee(root->left, emp_id);
    }
    return searchEmployee(root->right, emp_id);
}

// Perform inorder traversal of the binary search tree to sort employee records by emp_id
void inorderTraversal(struct employee *root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("Employee ID: %d, Name: %s\n", root->emp_id, root->name);
        inorderTraversal(root->right);
    }
}

int main() {
    struct employee *root = NULL;

    // Insert employee records into the binary search tree
    root = insertEmployee(root, 10, "John");
    root = insertEmployee(root, 7, "Alice");
    root = insertEmployee(root, 12, "Bob");
    root = insertEmployee(root, 5, "Eve");
    root = insertEmployee(root, 11, "Mike");

    // Search for an employee record by employee ID
    int search_id = 12;
    struct employee *foundEmployee = searchEmployee(root, search_id);
    if (foundEmployee != NULL) {
        printf("Employee ID: %d, Name: %s\n", foundEmployee->emp_id, foundEmployee->name);
    } else {
        printf("Employee with ID %d not found.\n", search_id);
    }

    // Display sorted employee records by emp_id
    printf("\nSorted Employee Records (by emp_id):\n");
    inorderTraversal(root);

    return 0;
}


  Write a Program to create Inorder Threaded Binary Tree and Traverse it in Preorder way.
________________________________________

       Write a Program to create Inorder Threaded Binary Tree and Traverse it in Inorder way.
________________________________________

       Write a Program to implement AVL tree and perform different rotations on it and display it Levelwise.
#include <stdio.h>  
#include <stdlib.h>  
   
struct Node  
{  
    int key;  
    struct Node *left;  
    struct Node *right;  
    int height;  
};  
   
int getHeight(struct Node *n){  
    if(n==NULL)  
        return 0;  
    return n->height;  
}  
   
struct Node *createNode(int key){  
    struct Node* node = (struct Node *) malloc(sizeof(struct Node));  
    node->key = key;  
    node->left = NULL;  
    node->right = NULL;  
    node->height = 1;  
    return node;  
}  
   
int max (int a, int b){  
    return (a>b)?a:b;  
}  
   
int getBalanceFactor(struct Node * n){  
    if(n==NULL){  
        return 0;  
    }  
    return getHeight(n->left) - getHeight(n->right);  
}  
   
struct Node* rightRotate(struct Node* y){  
    struct Node* x = y->left;  
    struct Node* T2 = x->right;  
   
    x->right = y;  
    y->left = T2;  
   
    x->height = max(getHeight(x->right), getHeight(x->left)) + 1;  
    y->height = max(getHeight(y->right), getHeight(y->left)) + 1;  
   
    return x;  
}  
   
struct Node* leftRotate(struct Node* x){  
    struct Node* y = x->right;  
    struct Node* T2 = y->left;  
   
    y->left = x;  
    x->right = T2;  
   
    x->height = max(getHeight(x->right), getHeight(x->left)) + 1;  
    y->height = max(getHeight(y->right), getHeight(y->left)) + 1;  
   
    return y;  
}  
   
struct Node *insert(struct Node* node, int key){  
    if (node == NULL)  
        return  createNode(key);  
   
    if (key < node->key)  
        node->left  = insert(node->left, key);  
    else if (key > node->key)  
        node->right = insert(node->right, key);  
   
    node->height = 1 + max(getHeight(node->left), getHeight(node->right));  
    int bf = getBalanceFactor(node);  
   
    // Left Left Case  
        if(bf>1 && key < node->left->key){  
            return rightRotate(node);  
        }  
    // Right Right Case  
        if(bf<-1 && key > node->right->key){  
            return leftRotate(node);  
        }  
    // Left Right Case  
    if(bf>1 && key > node->left->key){  
            node->left = leftRotate(node->left);  
            return rightRotate(node);  
        }  
    // Right Left Case  
    if(bf<-1 && key < node->right->key){  
            node->right = rightRotate(node->right);  
            return leftRotate(node);  
        }  
    return node;  
}  
int height(struct Node* node)
{
    if (node == NULL)
        return 0;
    else {
        
        // Compute the height of each subtree
        int lheight = height(node->left);
        int rheight = height(node->right);

        // Use the larger one
        if (lheight > rheight)
            return (lheight + 1);
        else
            return (rheight + 1);
    }
}

void printCurrentLevel(struct Node* root, int level)
{
    if (root == NULL)
        return;
    if (level == 1)
        printf("%d ", root->key);
    else if (level > 1) {
        printCurrentLevel(root->left, level - 1);
        printCurrentLevel(root->right, level - 1);
    }
}

void levelOrder(struct Node *root)
{   
    int h = height(root);
    int i;
    for (i = 1; i <= h; i++){
        printCurrentLevel(root, i);
        printf("\n");
    }
    printf("\n");
}  
   
int main(){  
    struct Node * root = NULL;  
    while (1)
    {
        int choice, num;
        printf("Press 1 to Insert a node\n");
        printf("Press 2 to Display the tree Levelwise\n");
        printf("Press 3 to Exit\n");
        printf("Enter your choice:\n");

        scanf("%d",&choice);

    switch (choice) {
    case 1: {
        int key;
        printf("Enter key:\n");
        scanf("%d",&key);
        root = insert(root, key);
        break;
    }
    case 2: {
        levelOrder(root);
        break;
    }
    case 3: {
        return 0;
    }
    default:
        printf("wrong Input\n");
    }
    }
    return 0;
    
} 

Write a Program to accept a graph from user and represent it with Adjacency Matrix and perform BFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 20

int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES];
int visited[MAX_VERTICES];
int queue[MAX_VERTICES];
int front = -1, rear = -1;
int vertices;

void createGraph()
{
    int i, j;
    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    printf("Enter the adjacency matrix:\n");
    for (i = 0; i < vertices; i++)
    {
        printf("Enter adjacency for vertex %d: ", i);
        for (j = 0; j < vertices; j++)
        {
            scanf("%d", &adjacencyMatrix[i][j]);
        }
    }
}

void initializeVisited()
{
    int i;
    for (i = 0; i < vertices; i++)
    {
        visited[i] = 0;
    }
}

void enqueue(int vertex)
{
    if (rear == MAX_VERTICES - 1)
    {
        printf("Queue Overflow!\n");
    }
    else
    {
        if (front == -1)
        {
            front = 0;
        }
        rear++;
        queue[rear] = vertex;
    }
}

int dequeue()
{
    int vertex;
    if (front == -1 || front > rear)
    {
        printf("Queue Underflow!\n");
        return -1;
    }
    else
    {
        vertex = queue[front];
        front++;
        return vertex;
    }
}

int isQueueEmpty()
{
    if (front == -1 || front > rear)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

void DFS(int vertex)
{
    int i;
    printf("%d ", vertex);
    visited[vertex] = 1;
    for (i = 0; i < vertices; i++)
    {
        if (adjacencyMatrix[vertex][i] == 1 && !visited[i])
        {
            DFS(i);
        }
    }
}

void BFS(int vertex)
{
    int i, dequeueVertex;
    printf("%d ", vertex);
    visited[vertex] = 1;
    enqueue(vertex);

    while (!isQueueEmpty())
    {
        dequeueVertex = dequeue();
        for (i = 0; i < vertices; i++)
        {
            if (adjacencyMatrix[dequeueVertex][i] == 1 && !visited[i])
            {
                printf("%d ", i);
                visited[i] = 1;
                enqueue(i);
            }
        }
    }
}

int main()
{
    int choice, startVertex;

    while (1)
    {
        printf("\nMENU\n");
        printf("1. Create Graph\n");
        printf("2. DFS\n");
        printf("3. BFS\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            createGraph();
            break;
        case 2:
            initializeVisited();
            printf("Enter the starting vertex for DFS: ");
            scanf("%d", &startVertex);
            printf("DFS Traversal: ");
            DFS(startVertex);
            printf("\n");
            break;
        case 3:
            initializeVisited();
            printf("Enter the starting vertex for BFS: ");
            scanf("%d", &startVertex);
            printf("BFS Traversal: ");
            BFS(startVertex);
            printf("\n");
            break;
        case 4:
            printf("Exiting program...\n");
            exit(0);
        default:
            printf("Invalid choice! Please enter a valid option.\n");
        }
    }

    return 0;
}

Write a Program to accept a graph from user and represent it with Adjacency Lists and perform BFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

struct AdjListNode {
    int dest;
    struct AdjListNode* next;
};

struct AdjList {
    struct AdjListNode* head;
};

struct Graph {
    int V;
    struct AdjList* array;
};

struct AdjListNode* newAdjListNode(int dest) {
    struct AdjListNode* newNode = (struct AdjListNode*)malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->next = NULL;
    return newNode;
}

struct Graph* createGraph(int V) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;
    graph->array = (struct AdjList*)malloc(V * sizeof(struct AdjList));
    for (int i = 0; i < V; ++i)
        graph->array[i].head = NULL;
    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    struct AdjListNode* newNode = newAdjListNode(dest);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;

   
    newNode = newAdjListNode(src);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

void DFS(struct Graph* graph, int start) {
    int* visited = (int*)calloc(graph->V, sizeof(int));
    int stack[graph->V];
    int top = -1;

    visited[start] = 1;
    stack[++top] = start;

    while (top != -1) {
        int current = stack[top--];
        printf("%d ", current);

        struct AdjListNode* temp = graph->array[current].head;
        while (temp != NULL) {
            if (!visited[temp->dest]) {
                visited[temp->dest] = 1;
                stack[++top] = temp->dest;
            }
            temp = temp->next;
        }
    }

    free(visited);
}

void BFS(struct Graph* graph, int start) {
    int* visited = (int*)calloc(graph->V, sizeof(int));
    int queue[graph->V];
    int front = 0, rear = 0;

    visited[start] = 1;
    queue[rear++] = start;

    while (front < rear) {
        int current = queue[front++];
        printf("%d ", current);

        struct AdjListNode* temp = graph->array[current].head;
        while (temp != NULL) {
            if (!visited[temp->dest]) {
                visited[temp->dest] = 1;
                queue[rear++] = temp->dest;
            }
            temp = temp->next;
        }
    }

    free(visited);
}

void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Add Edge\n");
    printf("2. Depth First Search (DFS)\n");
    printf("3. Breadth First Search (BFS)\n");
    printf("4. Exit\n");
}

int main() {
    int V, choice, src, dest;
    printf("Enter the number of vertices: ");
    scanf("%d", &V);

    struct Graph* graph = createGraph(V);

    while (1) {
        displayMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter source and destination vertices (0 to %d): ", V - 1);
                scanf("%d %d", &src, &dest);
                if (src >= 0 && src < V && dest >= 0 && dest < V)
                    addEdge(graph, src, dest);
                else
                    printf("Invalid vertices! Please enter vertices within the range.\n");
                break;
            case 2:
                printf("DFS Traversal: ");
                DFS(graph, 0);
                printf("\n");
                break;
            case 3:
                printf("BFS Traversal: ");
                BFS(graph, 0);
                printf("\n");
                break;
            case 4:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice! Please enter a valid option.\n");
        }
    }

    return 0;
}

Write a Program to accept a graph from user and represent it with Adjacency Matrix and perform DFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 20

int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES];
int visited[MAX_VERTICES];
int queue[MAX_VERTICES];
int front = -1, rear = -1;
int vertices;

void createGraph()
{
    int i, j;
    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    printf("Enter the adjacency matrix:\n");
    for (i = 0; i < vertices; i++)
    {
        printf("Enter adjacency for vertex %d: ", i);
        for (j = 0; j < vertices; j++)
        {
            scanf("%d", &adjacencyMatrix[i][j]);
        }
    }
}

void initializeVisited()
{
    int i;
    for (i = 0; i < vertices; i++)
    {
        visited[i] = 0;
    }
}

void enqueue(int vertex)
{
    if (rear == MAX_VERTICES - 1)
    {
        printf("Queue Overflow!\n");
    }
    else
    {
        if (front == -1)
        {
            front = 0;
        }
        rear++;
        queue[rear] = vertex;
    }
}

int dequeue()
{
    int vertex;
    if (front == -1 || front > rear)
    {
        printf("Queue Underflow!\n");
        return -1;
    }
    else
    {
        vertex = queue[front];
        front++;
        return vertex;
    }
}

int isQueueEmpty()
{
    if (front == -1 || front > rear)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

void DFS(int vertex)
{
    int i;
    printf("%d ", vertex);
    visited[vertex] = 1;
    for (i = 0; i < vertices; i++)
    {
        if (adjacencyMatrix[vertex][i] == 1 && !visited[i])
        {
            DFS(i);
        }
    }
}

void BFS(int vertex)
{
    int i, dequeueVertex;
    printf("%d ", vertex);
    visited[vertex] = 1;
    enqueue(vertex);

    while (!isQueueEmpty())
    {
        dequeueVertex = dequeue();
        for (i = 0; i < vertices; i++)
        {
            if (adjacencyMatrix[dequeueVertex][i] == 1 && !visited[i])
            {
                printf("%d ", i);
                visited[i] = 1;
                enqueue(i);
            }
        }
    }
}

int main()
{
    int choice, startVertex;

    while (1)
    {
        printf("\nMENU\n");
        printf("1. Create Graph\n");
        printf("2. DFS\n");
        printf("3. BFS\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            createGraph();
            break;
        case 2:
            initializeVisited();
            printf("Enter the starting vertex for DFS: ");
            scanf("%d", &startVertex);
            printf("DFS Traversal: ");
            DFS(startVertex);
            printf("\n");
            break;
        case 3:
            initializeVisited();
            printf("Enter the starting vertex for BFS: ");
            scanf("%d", &startVertex);
            printf("BFS Traversal: ");
            BFS(startVertex);
            printf("\n");
            break;
        case 4:
            printf("Exiting program...\n");
            exit(0);
        default:
            printf("Invalid choice! Please enter a valid option.\n");
        }
    }

    return 0;
}

Write a Program to accept a graph from user and represent it with Adjacency Lists and perform DFS traversals on it.
#include <stdio.h>
#include <stdlib.h>

struct AdjListNode {
    int dest;
    struct AdjListNode* next;
};

struct AdjList {
    struct AdjListNode* head;
};

struct Graph {
    int V;
    struct AdjList* array;
};

struct AdjListNode* newAdjListNode(int dest) {
    struct AdjListNode* newNode = (struct AdjListNode*)malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->next = NULL;
    return newNode;
}

struct Graph* createGraph(int V) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;
    graph->array = (struct AdjList*)malloc(V * sizeof(struct AdjList));
    for (int i = 0; i < V; ++i)
        graph->array[i].head = NULL;
    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    struct AdjListNode* newNode = newAdjListNode(dest);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;

   
    newNode = newAdjListNode(src);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

void DFS(struct Graph* graph, int start) {
    int* visited = (int*)calloc(graph->V, sizeof(int));
    int stack[graph->V];
    int top = -1;

    visited[start] = 1;
    stack[++top] = start;

    while (top != -1) {
        int current = stack[top--];
        printf("%d ", current);

        struct AdjListNode* temp = graph->array[current].head;
        while (temp != NULL) {
            if (!visited[temp->dest]) {
                visited[temp->dest] = 1;
                stack[++top] = temp->dest;
            }
            temp = temp->next;
        }
    }

    free(visited);
}

void BFS(struct Graph* graph, int start) {
    int* visited = (int*)calloc(graph->V, sizeof(int));
    int queue[graph->V];
    int front = 0, rear = 0;

    visited[start] = 1;
    queue[rear++] = start;

    while (front < rear) {
        int current = queue[front++];
        printf("%d ", current);

        struct AdjListNode* temp = graph->array[current].head;
        while (temp != NULL) {
            if (!visited[temp->dest]) {
                visited[temp->dest] = 1;
                queue[rear++] = temp->dest;
            }
            temp = temp->next;
        }
    }

    free(visited);
}

void displayMenu() {
    printf("\nMenu:\n");
    printf("1. Add Edge\n");
    printf("2. Depth First Search (DFS)\n");
    printf("3. Breadth First Search (BFS)\n");
    printf("4. Exit\n");
}

int main() {
    int V, choice, src, dest;
    printf("Enter the number of vertices: ");
    scanf("%d", &V);

    struct Graph* graph = createGraph(V);

    while (1) {
        displayMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter source and destination vertices (0 to %d): ", V - 1);
                scanf("%d %d", &src, &dest);
                if (src >= 0 && src < V && dest >= 0 && dest < V)
                    addEdge(graph, src, dest);
                else
                    printf("Invalid vertices! Please enter vertices within the range.\n");
                break;
            case 2:
                printf("DFS Traversal: ");
                DFS(graph, 0);
                printf("\n");
                break;
            case 3:
                printf("BFS Traversal: ");
                BFS(graph, 0);
                printf("\n");
                break;
            case 4:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice! Please enter a valid option.\n");
        }
    }

    return 0;
}

     Write a Program to implement Prim’s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

typedef struct Node {
    int vertex;
    int weight;
    struct Node* next;
} Node;

typedef struct {
    Node** head;
    int vertices;
} Graph;

Node* createNode(int vertex, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = vertex;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

Graph* createGraph(int vertices) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->vertices = vertices;
    graph->head = (Node**)malloc(vertices * sizeof(Node*));
    for (int i = 0; i < vertices; i++) {
        graph->head[i] = NULL;
    }
    return graph;
}

void addEdge(Graph* graph, int src, int dest, int weight) {
    Node* newNode = createNode(dest, weight);
    newNode->next = graph->head[src];
    graph->head[src] = newNode;

    newNode = createNode(src, weight);
    newNode->next = graph->head[dest];
    graph->head[dest] = newNode;
}

int minKey(int key[], int mstSet[], int vertices) {
    int min = INT_MAX, minIndex;
    for (int v = 0; v < vertices; v++) {
        if (mstSet[v] == 0 && key[v] < min) {
            min = key[v];
            minIndex = v;
        }
    }
    return minIndex;
}

void printMST(int parent[], int vertices, Graph* graph) {
    printf("Edge \tWeight\n");
    for (int i = 1; i < vertices; i++) {
        for (Node* node = graph->head[i]; node != NULL; node = node->next) {
            if (node->vertex == parent[i]) {
                printf("%d - %d \t%d \n", parent[i], i, node->weight);
                break;
            }
        }
    }
}

void primMST(Graph* graph) {
    int vertices = graph->vertices;
    int parent[vertices];
    int key[vertices];
    int mstSet[vertices];

    for (int i = 0; i < vertices; i++) {
        key[i] = INT_MAX;
        mstSet[i] = 0;
    }

    key[0] = 0;
    parent[0] = -1;

    for (int count = 0; count < vertices - 1; count++) {
        int u = minKey(key, mstSet, vertices);
        mstSet[u] = 1;

        for (Node* node = graph->head[u]; node != NULL; node = node->next) {
            int v = node->vertex;
            if (mstSet[v] == 0 && node->weight < key[v]) {
                parent[v] = u;
                key[v] = node->weight;
            }
        }
    }

    printMST(parent, vertices, graph);
}

int main() {
    int vertices, edges;
    printf("Enter number of vertices: ");
    scanf("%d", &vertices);
    printf("Enter number of edges: ");
    scanf("%d", &edges);

    Graph* graph = createGraph(vertices);

    printf("Enter edges (src dest weight):\n");
    for (int i = 0; i < edges; i++) {
        int src, dest, weight;
        scanf("%d %d %d", &src, &dest, &weight);
        if (src >= vertices || dest >= vertices || src < 0 || dest < 0) {
            printf("Invalid edge!\n");
            i--;
        } else {
            addEdge(graph, src, dest, weight);
        }
    }

    primMST(graph);

    for (int i = 0; i < vertices; i++) {
        Node* node = graph->head[i];
        while (node) {
            Node* temp = node;
            node = node->next;
            free(temp);
        }
    }
    free(graph->head);
    free(graph);

    return 0;
}
Write a Program to implement Kruskals’s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency Matrix to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_VERTICES 100

int comparator(const void* p1, const void* p2)
{
    const int (*x)[3] = p1;
    const int (*y)[3] = p2;

    return (*x)[2] - (*y)[2];
}

void makeSet(int parent[], int rank[], int n)
{
    for (int i = 0; i < n; i++)
    {
        parent[i] = i;
        rank[i] = 0;
    }
}

int findParent(int parent[], int component)
{
    if (parent[component] == component)
        return component;

    return parent[component] = findParent(parent, parent[component]);
}


void unionSet(int u, int v, int parent[], int rank[], int n)
{
    // Finding the parents
    u = findParent(parent, u);
    v = findParent(parent, v);

    if (rank[u] < rank[v])
    {
        parent[u] = v;
    }
    else if (rank[u] > rank[v])
    {
        parent[v] = u;
    }
    else
    {
        parent[v] = u;

        rank[u]++;
    }
}


void kruskalAlgo(int n, int edge[][3])
{
    
    qsort(edge, n, sizeof(edge[0]), comparator);

    int parent[n];
    int rank[n];

    makeSet(parent, rank, n);

    int minCost = 0;

    printf("Following are the edges in the constructed MST\n");
    for (int i = 0; i < n; i++)
    {
        int v1 = findParent(parent, edge[i][0]);
        int v2 = findParent(parent, edge[i][1]);
        int wt = edge[i][2];

        
        if (v1 != v2)
        {
            unionSet(v1, v2, parent, rank, n);
            minCost += wt;
            printf("%d -- %d == %d\n", edge[i][0],
                   edge[i][1], wt);
        }
    }

    printf("Minimum Cost Spanning Tree: %d\n", minCost);
}

void createAdjacencyMatrix(int numVertices, int adjacencyMatrix[][MAX_VERTICES])
{
    printf("Enter the adjacency matrix:\n");
    for (int i = 0; i < numVertices; i++)
    {
        for (int j = 0; j < numVertices; j++)
        {
            scanf("%d", &adjacencyMatrix[i][j]);
        }
    }
}

int main()
{
    int numVertices, numEdges;
    printf("Enter the number of vertices: ");
    scanf("%d", &numVertices);
    numEdges = numVertices * (numVertices - 1) / 2; // Assuming a complete graph

    int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES];
    createAdjacencyMatrix(numVertices, adjacencyMatrix);

    int edge[numEdges][3];
    int edgeCount = 0;

    // Converting adjacency matrix to edge list
    for (int i = 0; i < numVertices; i++)
    {
        for (int j = i + 1; j < numVertices; j++)
        {
            if (adjacencyMatrix[i][j] != 0)
            {
                edge[edgeCount][0] = i;
                edge[edgeCount][1] = j;
                edge[edgeCount][2] = adjacencyMatrix[i][j];
                edgeCount++;
            }
        }
    }

    kruskalAlgo(numEdges, edge);

    return 0;
}
Write a Program to implement Kruskal’s algorithm to find minimum spanning tree of a user defined graph. Use Adjacency List to represent a graph.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct Node {
    int vertex;
    int weight;
    struct Node* next;
} Node;

Node* createNode(int vertex, int weight) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    newNode->vertex = vertex;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

void addEdge(Node** head, int vertex, int weight) {
    Node* newNode = createNode(vertex, weight);
    newNode->next = *head;
    *head = newNode;
}

void printAdjacencyList(int numVertices, Node* adjacencyList[]) {
    for (int i = 0; i < numVertices; i++) {
        Node* current = adjacencyList[i];
        printf("Adjacency list for vertex %d: ", i);
        while (current != NULL) {
            printf("(%d, %d) ", current->vertex, current->weight);
            current = current->next;
        }
        printf("\n");
    }
}

void freeAdjacencyList(int numVertices, Node* adjacencyList[]) {
    for (int i = 0; i < numVertices; i++) {
        Node* current = adjacencyList[i];
        while (current != NULL) {
            Node* temp = current;
            current = current->next;
            free(temp);
        }
    }
}

void createEdgeList(int numVertices, Node* adjacencyList[], int edge[][3], int *numEdges) {
    int edgeCount = 0;
    for (int i = 0; i < numVertices; i++) {
        Node* current = adjacencyList[i];
        while (current != NULL) {
            edge[edgeCount][0] = i;
            edge[edgeCount][1] = current->vertex;
            edge[edgeCount][2] = current->weight;
            edgeCount++;
            current = current->next;
        }
    }
    *numEdges = edgeCount;
}

int comparator(const void* p1, const void* p2) {
    const int (*x)[3] = p1;
    const int (*y)[3] = p2;
    return (*x)[2] - (*y)[2];
}

int findParent(int parent[], int component) {
    if (parent[component] == component)
        return component;
    return parent[component] = findParent(parent, parent[component]);
}

void unionSet(int u, int v, int parent[], int rank[], int n) {
    u = findParent(parent, u);
    v = findParent(parent, v);
    if (rank[u] < rank[v]) {
        parent[u] = v;
    } else if (rank[u] > rank[v]) {
        parent[v] = u;
    } else {
        parent[v] = u;
        rank[u]++;
    }
}

void kruskalAlgo(int numEdges, int edge[][3], int numVertices) {
    qsort(edge, numEdges, sizeof(edge[0]), comparator);

    int parent[numVertices];
    int rank[numVertices];
    int minCost = 0;

    for (int i = 0; i < numVertices; i++) {
        parent[i] = i;
        rank[i] = 0;
    }

    printf("Following are the edges in the constructed MST\n");
    for (int i = 0; i < numEdges; i++) {
        int u = findParent(parent, edge[i][0]);
        int v = findParent(parent, edge[i][1]);
        int weight = edge[i][2];

        if (u != v) {
            printf("%d -- %d == %d\n", edge[i][0], edge[i][1], weight);
            minCost += weight;
            unionSet(u, v, parent, rank, numVertices);
        }
    }

    printf("Minimum Cost Spanning Tree: %d\n", minCost);
}

int main() {
    int numVertices;
    printf("Enter the number of vertices: ");
    scanf("%d", &numVertices);

    Node* adjacencyList[numVertices];
    for (int i = 0; i < numVertices; i++) {
        adjacencyList[i] = NULL;
        printf("Enter adjacency list for vertex %d (destination weight format) (-1 to terminate): ", i);
        int vertex, weight;
        while (true) {
            scanf("%d", &vertex);
            if (vertex == -1)
                break;
            scanf("%d", &weight);
            addEdge(&adjacencyList[i], vertex, weight);
        }
    }

    printAdjacencyList(numVertices, adjacencyList);

    int numEdges = numVertices * numVertices; // Max possible edges for a complete graph
    int edge[numEdges][3];
    int actualNumEdges;
    createEdgeList(numVertices, adjacencyList, edge, &actualNumEdges);

    kruskalAlgo(actualNumEdges, edge, numVertices);

    freeAdjacencyList(numVertices, adjacencyList);

    return 0;
}
Write a Program to implement Dijkstra’s algorithm to find shortest distance between two nodes of a user defined graph. Use Adjacency List to represent a graph
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdbool.h>

#define V 9

struct Node {
    int vertex, weight;
    struct Node* next;
};

void dijkstra(struct Node* adjList[], int src) {
    int dist[V];
    bool sptSet[V];

    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;

    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int u = -1;
        int min_dist = INT_MAX;


        for (int v = 0; v < V; v++) {
            if (!sptSet[v] && dist[v] < min_dist) {
                u = v;
                min_dist = dist[v];
            }
        }

        if (u == -1)
            break;

        sptSet[u] = true;

        struct Node* current = adjList[u];
        while (current != NULL) {
            int v = current->vertex;
            int weight = current->weight;
            if (!sptSet[v] && dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
            }
            current = current->next;
        }
    }

    printf("Vertex \t\t Distance from Source\n");
    for (int i = 0; i < V; i++)
        printf("%d \t\t\t\t %d\n", i, dist[i]);
}

struct Node* createNode(int v, int weight) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->vertex = v;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

void addEdge(struct Node* adjList[], int src, int dest, int weight) {
    struct Node* newNode = createNode(dest, weight);
    newNode->next = adjList[src];
    adjList[src] = newNode;

    newNode = createNode(src, weight);
    newNode->next = adjList[dest];
    adjList[dest] = newNode;
}

int main() {
    int numEdges;
    printf("Enter the number of edges: ");
    scanf("%d", &numEdges);

    struct Node* adjList[V];
    for (int i = 0; i < V; i++)
        adjList[i] = NULL;

    printf("Enter edges along with their weights (source destination weight):\n");
    int source, destination, weight;
    for (int i = 0; i < numEdges; i++) {
        scanf("%d %d %d", &source, &destination, &weight);
        addEdge(adjList, source, destination, weight);
    }

    dijkstra(adjList, 0);

    return 0;
}
Write a Program to implement Dijkstra’s algorithm to find shortest distance between two nodes of a user defined graph. Use Adjacency Matrix to represent a graph
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>

int minDistance(int dist[], bool sptSet[], int V) {
    int min = INT_MAX, min_index;

    for (int v = 0; v < V; v++)
        if (sptSet[v] == false && dist[v] <= min)
            min = dist[v], min_index = v;

    return min_index;
}

void printSolution(int dist[], int V) {
    printf("Vertex \t\t Distance from Source\n");
    for (int i = 0; i < V; i++) {
        if (dist[i] == INT_MAX)
            printf("%d \t\t\t\t Infinite\n", i);
        else
            printf("%d \t\t\t\t %d\n", i, dist[i]);
    }
}

void dijkstra(int **graph, int src, int V) {
    int dist[V];
    bool sptSet[V];

    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;

    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        int u = minDistance(dist, sptSet, V);

        sptSet[u] = true;

        for (int v = 0; v < V; v++)
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])
                dist[v] = dist[u] + graph[u][v];
    }

    printSolution(dist, V);
}

int main() {
    int V;
    printf("Enter the number of vertices in the graph: ");
    scanf("%d", &V);

    int **graph = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
        graph[i] = (int *)malloc(V * sizeof(int));

    printf("Enter the adjacency matrix of the graph (%d x %d):\n", V, V);
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    int src;
    printf("Enter the source vertex: ");
    scanf("%d", &src);

    dijkstra(graph, src, V);

    
    for (int i = 0; i < V; i++)
        free(graph[i]);
    free(graph);

    return 0;
}

________________________________________
WAP to implement Heap sort on 1D array of Student structure (contains student_name, student_roll_no, total_marks), with key as student_roll_no. And count the number of swap performed.
#include <stdio.h>
#include <string.h>

// Define the Student structure
typedef struct {
    char student_name[50];
    int student_roll_no;
    float total_marks;
} Student;

// Function prototypes
void heapify(Student arr[], int n, int i, int *swap_count);
void heapSort(Student arr[], int n, int *swap_count);
void swap(Student *a, Student *b);

// Heapify function to maintain heap property
void heapify(Student arr[], int n, int i, int *swap_count) {
    int largest = i; // Initialize largest as root
    int left = 2 * i + 1; // left = 2*i + 1
    int right = 2 * i + 2; // right = 2*i + 2

    // If left child is larger than root
    if (left < n && arr[left].student_roll_no > arr[largest].student_roll_no)
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right].student_roll_no > arr[largest].student_roll_no)
        largest = right;

    // If largest is not root
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        (*swap_count)++;
        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest, swap_count);
    }
}

// Function to perform heap sort
void heapSort(Student arr[], int n, int *swap_count) {
    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i, swap_count);

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        swap(&arr[0], &arr[i]);
        (*swap_count)++;
        // Call max heapify on the reduced heap
        heapify(arr, i, 0, swap_count);
    }
}

// Function to swap two students
void swap(Student *a, Student *b) {
    Student temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int swap_count = 0;

    // Sample array of students
    Student students[] = {
        {"Alice", 3, 88.5},
        {"Bob", 1, 91.2},
        {"Charlie", 4, 75.0},
        {"David", 2, 82.3}
    };
    
    int n = sizeof(students) / sizeof(students[0]);

    // Perform heap sort
    heapSort(students, n, &swap_count);

    // Print sorted array
    printf("Sorted array by student_roll_no:\n");
    for (int i = 0; i < n; i++) {
        printf("Name: %s, Roll No: %d, Total Marks: %.2f\n", students[i].student_name, students[i].student_roll_no, students[i].total_marks);
    }

    // Print the number of swaps performed
    printf("Number of swaps performed: %d\n", swap_count);

    return 0;
}



WAP to implement Quick sort on 1D array of Employee structure (contains employee_name, emp_no, emp_salary), with key as emp_no. And count the number of swap performed.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char employee_name[50];
    int emp_no;
    float emp_salary;
} Employee;

int swap_count = 0;

void swap(Employee *a, Employee *b) {
    Employee temp = *a;
    *a = *b;
    *b = temp;
    swap_count++;
}

int partition(Employee arr[], int low, int high) {
    int pivot = arr[high].emp_no;
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr[j].emp_no < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(Employee arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int empNoExists(Employee arr[], int size, int emp_no) {
    for (int i = 0; i < size; i++) {
        if (arr[i].emp_no == emp_no) {
            return 1;
        }
    }
    return 0;
}

int main() {
    int n;
    printf("Enter the number of employees: ");
    if (scanf("%d", &n) != 1 || n <= 0) {
        printf("Invalid number of employees.\n");
        return 1;
    }

    Employee *arr = (Employee *)malloc(n * sizeof(Employee));
    if (arr == NULL) {
        printf("Memory allocation error.\n");
        return 1;
    }

    for (int i = 0; i < n; i++) {
        printf("Enter details for employee %d\n", i + 1);
        printf("Name: ");
        scanf("%s", arr[i].employee_name);
        printf("Employee Number: ");
        int emp_no;
        while (1) {
            if (scanf("%d", &emp_no) != 1) {
                printf("Invalid input for employee number. Try again: ");
                while (getchar() != '\n'); // Clear invalid input
            } else if (empNoExists(arr, i, emp_no)) {
                printf("Employee number already exists. Enter a unique employee number: ");
            } else {
                arr[i].emp_no = emp_no;
                break;
            }
        }
        printf("Salary: ");
        if (scanf("%f", &arr[i].emp_salary) != 1) {
            printf("Invalid input for salary.\n");
            free(arr);
            return 1;
        }
    }

    quickSort(arr, 0, n - 1);

    printf("Sorted list of employees based on employee number:\n");
    for (int i = 0; i < n; i++) {
        printf("Name: %s, Employee Number: %d, Salary: %.2f\n",
               arr[i].employee_name, arr[i].emp_no, arr[i].emp_salary);
    }

    printf("Number of swaps performed: %d\n", swap_count);

    free(arr);
    return 0;
}



Assume that an array A with n elements was sorted in an ascending order, but two of its elements swapped their positions by a mistake while maintaining the array. Write a code to identify the swapped pair of elements and their positions in the asymptotically best possible time. [Assume that all given elements are distinct integers.]

#include <stdio.h>

void findSwappedElements(int arr[], int n) {
    int x = -1, y = -1; 
    int i;

    for (i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            x = arr[i];
            break;
        }
    }

    for (i = n - 1; i > 0; i--) {
        if (arr[i] < arr[i - 1]) {
            y = arr[i];
            break;
        }
    }

    int posX = -1, posY = -1;
    for (i = 0; i < n; i++) {
        if (arr[i] == x) {
            posX = i;
        } else if (arr[i] == y) {
            posY = i;
        }
    }

    if (posX != -1 && posY != -1) {
        printf("The swapped elements are %d and %d\n", x, y);
        printf("Their positions are %d and %d\n", posX, posY);
    } else {
        printf("No swapped elements found.\n");
    }
}

int main() {
    int n, i;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];
    printf("Enter the elements of the array:\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    findSwappedElements(arr, n);

    return 0;
}



Implement following hashing Techniques by assuming suitable input and Table Size.
a.	Linear Probing With Chaining Without Replacement
Also mention number of collisions occurred while inserting a Data in hash table.
#include <stdio.h>
#include <stdlib.h>

#define TABLE_SIZE 10 // Define the size of the hash table
#define EMPTY -1      // Define the marker for empty slots

typedef struct {
    int data;
    int chain;
} HashEntry;

HashEntry hashTable[TABLE_SIZE];
int collisionCount = 0;

// Hash function
int hashFunction(int key) {
    return key % TABLE_SIZE;
}

// Initialize the hash table
void initializeTable() {
    for (int i = 0; i < TABLE_SIZE; i++) {
        hashTable[i].data = EMPTY;
        hashTable[i].chain = EMPTY;
    }
}

// Function to insert data into the hash table
void insert(int key) {
    int index = hashFunction(key);
    
    if (hashTable[index].data == EMPTY) {
        hashTable[index].data = key;
    } else {
        collisionCount++;
        int originalIndex = index;
        while (hashTable[index].data != EMPTY) {
            index = (index + 1) % TABLE_SIZE;
            if (index == originalIndex) {
                printf("Hash table is full!\n");
                return;
            }
        }
        // Insert the new key
        hashTable[index].data = key;
        
        // Update the chain
        int chainIndex = hashFunction(key);
        while (hashTable[chainIndex].chain != EMPTY) {
            chainIndex = hashTable[chainIndex].chain;
        }
        hashTable[chainIndex].chain = index;
    }
}

// Function to display the hash table
void displayTable() {
    printf("Index\tData\tChain\n");
    for (int i = 0; i < TABLE_SIZE; i++) {
        printf("%d\t%d\t%d\n", i, hashTable[i].data, hashTable[i].chain);
    }
}

int main() {
    int data, n;
    initializeTable();

    printf("Enter the number of elements to insert: ");
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("Enter data %d: ", i + 1);
        scanf("%d", &data);
        insert(data);
    }

    displayTable();
    printf("Number of collisions: %d\n", collisionCount);

    return 0;
}



Implement following hashing Techniques by assuming suitable input and Table Size.
a.	Linear Probing With Chaining With Replacement
Also mention number of collisions occurred while inserting a Data in hash table.
#include <stdio.h>
#include <stdlib.h>

#define TABLE_SIZE 10 // Define the size of the hash table
#define EMPTY -1      // Define the marker for empty slots

typedef struct {
    int data;
    int chain;
} HashEntry;

HashEntry hashTable[TABLE_SIZE];
int collisionCount = 0;

// Hash function
int hashFunction(int key) {
    return key % TABLE_SIZE;
}

// Initialize the hash table
void initializeTable() {
    for (int i = 0; i < TABLE_SIZE; i++) {
        hashTable[i].data = EMPTY;
        hashTable[i].chain = EMPTY;
    }
}

// Function to insert data into the hash table
void insert(int key) {
    int index = hashFunction(key);
    
    if (hashTable[index].data == EMPTY) {
        hashTable[index].data = key;
    } else {
        collisionCount++;
        // If the current index contains an element with a different home position, replace it
        int currentIndex = index;
        int tempData = hashTable[currentIndex].data;
        int tempChain = hashTable[currentIndex].chain;

        if (hashFunction(tempData) != currentIndex) {
            hashTable[currentIndex].data = key;
            key = tempData;

            // Fix the chain of the displaced element
            int originalIndex = hashFunction(key);
            while (hashTable[originalIndex].chain != currentIndex) {
                originalIndex = hashTable[originalIndex].chain;
            }
            hashTable[originalIndex].chain = tempChain;
        }

        // Linear probing to find the next available slot
        while (hashTable[index].data != EMPTY) {
            index = (index + 1) % TABLE_SIZE;
        }
        
        // Insert the new key
        hashTable[index].data = key;

        // Update the chain for the original slot
        int chainIndex = hashFunction(key);
        while (hashTable[chainIndex].chain != EMPTY) {
            chainIndex = hashTable[chainIndex].chain;
        }
        hashTable[chainIndex].chain = index;
    }
}

// Function to display the hash table
void displayTable() {
    printf("Index\tData\tChain\n");
    for (int i = 0; i < TABLE_SIZE; i++) {
        printf("%d\t%d\t%d\n", i, hashTable[i].data, hashTable[i].chain);
    }
}

int main() {
    int data, n;
    initializeTable();

    printf("Enter the number of elements to insert: ");
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("Enter data %d: ", i + 1);
        scanf("%d", &data);
        insert(data);
    }

    displayTable();
    printf("Number of collisions: %d\n", collisionCount);

    return 0;
}





